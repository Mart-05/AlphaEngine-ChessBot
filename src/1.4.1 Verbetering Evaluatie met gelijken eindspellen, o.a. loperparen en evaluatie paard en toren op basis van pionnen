
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#ifdef WIN64
    #include <windows.h>
#else
    # include <sys/time.h>
#endif


/**************

MACROS

***************/
//Shortcuts voor later: #define [naam] [betekenis (waar de shortcut voor staat)].
#define U64 unsigned long long
#define set_bit(bitboard, square) ((bitboard) |= (1ULL << (square)))
#define get_bit(bitboard, square) ((bitboard) & (1ULL << (square)))
#define pop_bit(bitboard, square) ((bitboard) &= ~(1ULL << (square)))

//Nuttige posities voor debuggen.
#define empty_board "8/8/8/8/8/8/8/8 w - - "
#define start_position "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1 "
#define tricky_position "r3k2r/p1ppqpb1/bn2pnp1/3PN3/1p2P3/2N2Q1p/PPPBBPPP/R3K2R w KQkq - 0 1 "
#define killer_position "rnbqkb1r/pp1p1pPp/8/2p1pP2/1P1P4/3P3P/P1P1P3/RNBQKBNR w KQkq e6 0 1"
#define dumb_ai "8/5p2/1p1k1p1p/p1p2P1P/P1P2KP1/2P5/8/8 b - - 3 49 "
#define draw_position "krn5/ppp5/8/8/8/8/8/KRN5 w KQkq - 0 1 "
#define repetitions "2r3k1/R7/8/1R6/8/8/P4KPP/8 w - - 0 40 "


/**************

BOARD ENUM

***************/
//Rij voor namen van vakjes op het spelbord. Hiermee kan je de computer vertellen print ... of vakje c4 en dan doet die dat. (en mogelijkheden voor kleur/stukken die met lijnen gaan).
enum {
    a8, b8, c8, d8, e8, f8, g8, h8,
    a7, b7, c7, d7, e7, f7, g7, h7,
    a6, b6, c6, d6, e6, f6, g6, h6,
    a5, b5, c5, d5, e5, f5, g5, h5,
    a4, b4, c4, d4, e4, f4, g4, h4,
    a3, b3, c3, d3, e3, f3, g3, h3,
    a2, b2, c2, d2, e2, f2, g2, h2,
    a1, b1, c1, d1, e1, f1, g1, h1, no_sq
};

//Mogelijkheden voor soorten bitboards.
enum { white, black, both };
//Sliding pieces.
enum { rook, bishop };

//Kleuren en kant voor mogelijke toegestane casteling (schaakmove) aangegeven in bits. Hierbij staat w voor white, b voor black, q voor queenside en k voor kingside.
enum { wk = 1, wq = 2, bk = 4, bq = 8 };
//Alle mogelijke stukken in het spel met hoofdletters voor witte stukken.
enum { P, N, B, R, Q, K, p, n, b, r, q, k };

//Vakje naar coÃ¶rdinaten: voor vertaling van computertaal naar mensentaal.
char* square_to_coordinates[] = {
    "a8", "b8", "c8", "d8", "e8", "f8", "g8", "h8",
    "a7", "b7", "c7", "d7", "e7", "f7", "g7", "h7",
    "a6", "b6", "c6", "d6", "e6", "f6", "g6", "h6",
    "a5", "b5", "c5", "d5", "e5", "f5", "g5", "h5",
    "a4", "b4", "c4", "d4", "e4", "f4", "g4", "h4",
    "a3", "b3", "c3", "d3", "e3", "f3", "g3", "h3",
    "a2", "b2", "c2", "d2", "e2", "f2", "g2", "h2",
    "a1", "b1", "c1", "d1", "e1", "f1", "g1", "h1",
};

//Ascii: American Standard Code for Information Interchange. Geen flauw idee.
char ascii_pieces[] = "PNBRQKpnbrqk";

//Van integer naar character dus van P naar 'P'. Dit is handig voor het printen en debuggen.
int char_pieces[] = {
    ['P'] = P,
    ['N'] = N,
    ['B'] = B,
    ['R'] = R,
    ['Q'] = Q,
    ['K'] = K,
    ['p'] = p,
    ['n'] = n,
    ['b'] = b,
    ['r'] = r,
    ['q'] = q,
    ['k'] = k
};

//Aantal bitboards per stuk, p,r,n,b,q,k voor wit en zwart is 12.
U64 bitboards[12];
//Aantal bitboards voor wit, zwart en beide.
U64 occupancies[3];

//Game states: Kant, enpassant mogelijkheid en castling mogelijkheid.
int side;
int enpassant = no_sq;
int castle;

// pseudo random position identifiers (naast collisions)
U64 hash_key;

//Repetition table voor repetitions/draw herkennen
U64 repetition_table[1000];

//Repetition index
int repetition_index;

//Half move counter
int ply;

//Fifty move rule counter
int fifty;

/**************

Time control variabelen

***************/

// exit from engine flag
int quit = 0;

// UCI "movestogo" command moves counter
int movestogo = 30;

// UCI "movetime" command time counter
int movetime = -1;

// UCI "time" command holder (ms)
int time = -1;

// UCI "inc" command's time increment holder
int inc = 0;

// UCI "starttime" command time holder
int starttime = 0;

// UCI "stoptime" command time holder
int stoptime = 0;

// variable to flag time control availability
int timeset = 0;

// variable to flag when the time is up
int stopped = 0;


/**************

Miscellaneous functions

***************/

// get time in milliseconds
int get_time_ms()
{
    #ifdef WIN64
        return GetTickCount();
    #else
        struct timeval time_value;
        gettimeofday(&time_value, NULL);
        return time_value.tv_sec * 1000 + time_value.tv_usec / 1000;
    #endif
}

/*
  Function to "listen" to GUI's input during search.
  It's waiting for the user input from STDIN.
  OS dependent.

  First Richard Allbert aka BluefeverSoftware grabbed it from somewhere...
  And then Code Monkey King has grabbed it from VICE)

*/

int input_waiting()
{
#ifndef WIN32
    fd_set readfds;
    struct timeval tv;
    FD_ZERO(&readfds);
    FD_SET(fileno(stdin), &readfds);
    tv.tv_sec = 0; tv.tv_usec = 0;
    select(16, &readfds, 0, 0, &tv);

    return (FD_ISSET(fileno(stdin), &readfds));
#else
    static int init = 0, pipe;
    static HANDLE inh;
    DWORD dw;

    if (!init)
    {
        init = 1;
        inh = GetStdHandle(STD_INPUT_HANDLE);
        pipe = !GetConsoleMode(inh, &dw);
        if (!pipe)
        {
            SetConsoleMode(inh, dw & ~(ENABLE_MOUSE_INPUT | ENABLE_WINDOW_INPUT));
            FlushConsoleInputBuffer(inh);
        }
    }

    if (pipe)
    {
        if (!PeekNamedPipe(inh, NULL, 0, NULL, &dw, NULL)) return 1;
        return dw;
    }

    else
    {
        GetNumberOfConsoleInputEvents(inh, &dw);
        return dw <= 1 ? 0 : dw;
    }

#endif
}

// read GUI/user input
void read_input()
{
    // bytes to read holder
    int bytes;

    // GUI/user input
    char input[256] = "", *endc;

    // "listen" to STDIN
    if (input_waiting())
    {
        // tell engine to stop calculating
        stopped = 1;

        // loop to read bytes from STDIN
        do
        {
            // read bytes from STDIN
            bytes = read(fileno(stdin), input, 256);
        }

        // until bytes available
        while (bytes < 0);

        // searches for the first occurrence of '\n'
        endc = strchr(input, '\n');

        // if found new line set value at pointer to 0
        if (endc) *endc = 0;

        // if input is available
        if (strlen(input) > 0)
        {
            // match UCI "quit" command
            if (!strncmp(input, "quit", 4))
            {
                // tell engine to terminate exacution
                quit = 1;
            }

            // // match UCI "stop" command
            else if (!strncmp(input, "stop", 4)) {
                // tell engine to terminate exacution
                quit = 1;
            }
        }
    }
}

// a bridge function to interact between search and GUI input
static void communicate() {
    // if time is up break here
    if (timeset == 1 && get_time_ms() > stoptime) {
        // tell engine to stop calculating
        stopped = 1;
    }

    // read GUI input
    read_input();
}


/**************

RANDOMS
Dit geeft altijd dezelfde nummers in dezelfde volgorde want gaat volgens een algortime.

***************/
//Pseudo random number state, lijkt random maar is volgens een algoritme (Xor shift).
unsigned int state = 1804289383;

//Maak een 32-bit pseudo random number.
unsigned int get_random_U32_number()
{
    //Krijg state die het op dat moment is.
    unsigned int number = state;

    //Xor shift algorithm. (32-bit pseudo random generator algorithm)
    //Number = number ^ leftshift met 13 bits.
    number ^= number << 13;
    //Number = number ^ rightshift met 17 bits.
    number ^= number >> 17;
    //Number = number ^ leftshift met 5 bits.
    number ^= number << 5;

    //Update number naar state.
    state = number;

    return number;
}

//Maak een 64-bit pseudo random number.
U64 get_random_U64_number()
{
    //Namen voor 4 verschillende random nummers.
    U64 n1, n2, n3, n4;

    //Geef de 4 random nummers waardes en "slice" ze naar 16-bit.
    n1 = (U64)(get_random_U32_number()) & 0xFFFF;
    n2 = (U64)(get_random_U32_number()) & 0xFFFF;
    n3 = (U64)(get_random_U32_number()) & 0xFFFF;
    n4 = (U64)(get_random_U32_number()) & 0xFFFF;

    //Zet ze achter elkaar en niet op elkaar (elke random nummer bestaat uit 16 bits).
    return n1 | (n2 << 16) | (n3 << 32) | (n4 << 48);
}

//Maak magic number mogelijkheden.
U64 generate_magic_number()
{
    //Alleen de bits die bij alle 3 de random nummers 1 zijn.
    return get_random_U64_number() & get_random_U64_number() & get_random_U64_number();
}


/**************

BIT MANIP

***************/

//Telt het aantal bits op het bitboard dat aan(1) staat.
static inline int count_bits(U64 bitboard)
{
    int count = 0;
    while (bitboard)
    {
        count++;
        bitboard &= bitboard - 1;
    }
    return count;
}

//Pak de eerste bit. Van linksboven naar rechtsonder. (ls1b = last significant 1st bit).
static inline int get_ls1b_index(U64 bitboard)
{
    //Als bitboard niet gelijk is aan 0.
    if (bitboard)
    {
        // count trailing bits before LS1B
        return count_bits((bitboard & -bitboard) - 1);
    }

    //otherwise
    else
        // return illegal index
        return -1;
}
/**************

ZOBRIST

***************/
// random piece keys [soort stuk][positie(vakjes)]
U64 piece_keys[12][64];

//random enpassant keys [positie(vakjes)]
U64 enpassant_keys[64];

//Random castling keys
U64 castle_keys[16];

//random side key
U64 side_key;

//init de random hash keys
void init_random_keys()
{
    //update pseudo random number state
    state = 1804289383;

    //loop over piece codes
    for (int piece = P; piece <= k; piece++)
    {
        // loop over board squares
        for (int square = 0; square < 64; square++)
        //init random piece keys
        piece_keys[piece][square] = get_random_U64_number();

    }
    // loop over board squares
    for (int square = 0; square < 64; square++)
        //init random enpassant keys
        enpassant_keys[square] = get_random_U64_number();

    //init random side key
    side_key = get_random_U64_number();

    //loop over castling keys
    for (int index = 0; index < 16; index++)
        //init castle keys
        castle_keys[index] = get_random_U64_number();
}
//generate pseudorandom position identifier (hash key) From scratch
U64 generate_hash_key()
{
    //final hash key
    U64 final_key = 0ULL;

    // bitboard copy
    U64 bitboard;

    //loop over piece bit boards
    for (int piece = P; piece <= k; piece++)
    {
        //init piece bitboard copy
        bitboard = bitboards[piece];

        //loop over pieces binnen bitbaord
        while (bitboard)
        {
            //init square occupied by piece
            int square = get_ls1b_index(bitboard);

            //hash piece (add piece to key)
            final_key ^= piece_keys[piece][square];

            //pop ls1b
            pop_bit(bitboard,square);
        }
    }
    //if enpassant square is op bord
    if (enpassant != no_sq)
        //hash enpassant
        final_key ^= enpassant_keys[enpassant];

    //hash castling rights
    final_key ^= castle_keys[castle];

    //hash the side only if black een zet moet doen
    if (side == black) final_key ^= side_key;

    //return deze hash_key
    return final_key;
}

/**************

INPUT & OUTPUT

***************/
void print_bitboard(U64 bitboard)
{
    printf("\n");
    //Herhaald 9x voor het aantal horizontale rijen (0, 1, 2, 3, 4, 5, 6, 7, 8).
    for (int rank = 0; rank < 8; rank++)
    {
        //Herhaald 8x voor het aantal verticale rijen voor nu (0, 1, 2, 3, 4, 5, 6, 7, 8) maar eigenlijk (a, b, c, d, e, f, g, h). Dan zijn alle vakjes geweest want je hebt 8x8 + een rij onder en links om de naam van het vakje aan te geven.
        for (int file = 0; file < 8; file++)
        {
            //Benoemd het nummer van het vakje van linksboven naar rechtsonder. Linksboven dus 1, daarna 2 en als laatste 64 rechtsonder.
            int square = rank * 8 + file;
            //Als het de eerste verticale rij is (rij 0), dan print van 1 tot 8 (dit is de rij links van het spelbord die aangeeft op welke rij je zit).
            if (file == 0)
            {
                printf("  %d ", 8 - rank);
            }
            //Print de bit status van een vakje, dit is of 1 of 0.
            printf(" %d", get_bit(bitboard, square) ? 1 : 0);
        }
        //Witregel.
        printf("\n");
    }
    //Print kolom letters onderaan.
    printf("\n     a b c d e f g h\n\n");
    printf("     Bitboard: %llu\n\n", bitboard);
}

//Print board.
void print_board()
{
    //Nieuwe regel.
    printf("\n");
    //Loop ranks.
    for (int rank = 0; rank < 8; rank++)
    {
        //Loop files.
        for (int file = 0; file < 8; file++)
        {
            //Geef vakjes nummers van 1 tot 64
            int square = rank * 8 + file;

            //Print 1 tot 9 links van het bord voor rijen.
            if (!file)
            {
                printf("  %d ", 8 - rank);
            }

            //Deffinieer variabele piece.
            int piece = -1;

            //Voor alle stukken, kijken welk stuk het is.
            for (int bitboard_piece = P; bitboard_piece <= k; bitboard_piece++)
            {
                if (get_bit(bitboards[bitboard_piece], square)) piece = bitboard_piece;
            }

            //Als geen stuk, dan ".", als wel een stuk, print het stuk op een 8x8 veld.
            printf(" %c", (piece == -1) ? '.' : ascii_pieces[piece]);
        }
        //Nieuwe regel.
        printf("\n");
    }
    //Print a tot h onderaan.
    printf("\n     a b c d e f g h\n\n");
    //Print kant aan zet.
    printf("  Side:        %s\n", !side ? "White" : "Black");
    //Print enpassant mogelijheden.
    printf("  Enpassant:   %s\n", (enpassant != no_sq) ? square_to_coordinates[enpassant] : "No");
    //Print castling mogelijkheden.
    printf("  Castling:    %c%c%c%c\n\n",
        (castle & wk) ? 'K' : '-',
        (castle & wq) ? 'Q' : '-',
        (castle & bk) ? 'k' : '-',
        (castle & bq) ? 'q' : '-');
    // print hash key
    printf("     Hash key:  %llx\n", hash_key);
    // fifty move rule counter
    printf("     Fifty move: %d\n\n", fifty);
}

//Fen naar board.
void parse_fen(char* fen)
{
    //Reset bitboard naar alles 0.
    memset(bitboards, 0ULL, sizeof(bitboards));
    //Reset occupancies
    memset(occupancies, 0ULL, sizeof(occupancies));

    //Reset game states/variables.
    side = 0;
    enpassant = no_sq;
    castle = 0;

    //Reset repetitie index
    repetition_index = 0;

    // reset fifty move rule counter
    fifty = 0;

    //Reset repetition table
    memset(repetition_table, 0ULL, sizeof(repetition_table));
    printf("ply: %d\n", ply);
    // loop over board ranks
    for (int rank = 0; rank < 8; rank++)
    {
        // loop over board files
        for (int file = 0; file < 8; file++)
        {
            // init current square
            int square = rank * 8 + file;
            // match ascii pieces within FEN string
            if ((*fen >= 'a' && *fen <= 'z') || (*fen >= 'A' && *fen <= 'Z'))
            {
                // init piece type
                int piece = char_pieces[*fen];
                // set piece on corresponding bitboard
                set_bit(bitboards[piece], square);
                // increment pointer to FEN string
                fen++;
            }
            // match empty square numbers within FEN string
            if (*fen >= '0' && *fen <= '9')
            {
                // init offset (convert char 0 to int 0)
                int offset = *fen - '0';
                // define piece variable
                int piece = -1;
                // loop over all piece bitboards
                for (int bb_piece = P; bb_piece <= k; bb_piece++)
                {
                    // if there is a piece on current square
                    if (get_bit(bitboards[bb_piece], square))
                        // get piece code
                        piece = bb_piece;
                }
                // on empty current square
                if (piece == -1)
                    // decrement file
                    file--;
                // adjust file counter
                file += offset;
                // increment pointer to FEN string
                fen++;
            }
            // match rank separator
            if (*fen == '/')
                // increment pointer to FEN string
                fen++;
        }
    }

    //Weer volgende teken in fen.
    fen++;
    //Wie is aan zet.
    (*fen == 'w') ? (side = white) : (side = black);
    //Twee tekens overslaan in fen.
    fen += 2;
    //Zolang fen =geen spatie, kijk naar castlingmogelijkheden.
    while (*fen != ' ')
    {
        switch (*fen)
        {
        case 'K': castle |= wk; break;
        case 'Q': castle |= wq; break;
        case 'k': castle |= bk; break;
        case 'q': castle |= bq; break;
        case '-': break;
        }
        //Volgende teken in fen.
        fen++;
    }
    //Volgende teken in fen.
    fen++;
    //Als teken in fen geen streepje is:
    if (*fen != '-')
    {
        //Geef het vakje aan dat enpassant kan worden geslagen.
        int file = fen[0] - 'a';
        int rank = 8 - (fen[1] - '0');
        enpassant = rank * 8 + file;
    }
    //Anders:
    else
    {
        enpassant = no_sq;
    }

    // go to parsing half move counter (increment pointer to FEN string)
    fen++;
    // parse half move counter to init fifty move counter
    fifty = atoi(fen);

    //Occupancies voor wit.
    for (int piece = P; piece <= K; piece++) occupancies[white] |= bitboards[piece];
    //Occupancies voor zwart.
    for (int piece = p; piece <= k; piece++) occupancies[black] |= bitboards[piece];
    //Occupancies voor beide.
    occupancies[both] |= occupancies[white];
    occupancies[both] |= occupancies[black];

    //init hash key
    hash_key = generate_hash_key();
}

/**************

ATTACKS

***************/
//Bitboard voor niet de a kolom.
const U64 not_a_file = 18374403900871474942ULL;
//Bitboard voor niet de h kolom.
const U64 not_h_file = 9187201950435737471ULL;
//Bitboard voor niet de g of h kolom.
const U64 not_gh_file = 4557430888798830399ULL;
//Bitboard voor niet de a of b kolom.
const U64 not_ab_file = 18229723555195321596ULL;

//Aantal relevant vakjes dat de bishop aanvalt op elk vakje (zijden zijn niet relevant tenzij de bishop op een zijkant staat).
const int bishop_relevant_bits[64] = {
    6, 5, 5, 5, 5, 5, 5, 6,
    5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 7, 7, 7, 7, 5, 5,
    5, 5, 7, 9, 9, 7, 5, 5,
    5, 5, 7, 9, 9, 7, 5, 5,
    5, 5, 7, 7, 7, 7, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5,
    6, 5, 5, 5, 5, 5, 5, 6
};

//Aantal relevant vakjes dat de rook aanvalt op elk vakje (zijden zijn niet relevant tenzij de rook op een zijkant staat).
const int rook_relevant_bits[64] = {
    12, 11, 11, 11, 11, 11, 11, 12,
    11, 10, 10, 10, 10, 10, 10, 11,
    11, 10, 10, 10, 10, 10, 10, 11,
    11, 10, 10, 10, 10, 10, 10, 11,
    11, 10, 10, 10, 10, 10, 10, 11,
    11, 10, 10, 10, 10, 10, 10, 11,
    11, 10, 10, 10, 10, 10, 10, 11,
    12, 11, 11, 11, 11, 11, 11, 12
};

//rook magic numbers
U64 rook_magic_numbers[64] = {
    0x8a80104000800020ULL,
    0x140002000100040ULL,
    0x2801880a0017001ULL,
    0x100081001000420ULL,
    0x200020010080420ULL,
    0x3001c0002010008ULL,
    0x8480008002000100ULL,
    0x2080088004402900ULL,
    0x800098204000ULL,
    0x2024401000200040ULL,
    0x100802000801000ULL,
    0x120800800801000ULL,
    0x208808088000400ULL,
    0x2802200800400ULL,
    0x2200800100020080ULL,
    0x801000060821100ULL,
    0x80044006422000ULL,
    0x100808020004000ULL,
    0x12108a0010204200ULL,
    0x140848010000802ULL,
    0x481828014002800ULL,
    0x8094004002004100ULL,
    0x4010040010010802ULL,
    0x20008806104ULL,
    0x100400080208000ULL,
    0x2040002120081000ULL,
    0x21200680100081ULL,
    0x20100080080080ULL,
    0x2000a00200410ULL,
    0x20080800400ULL,
    0x80088400100102ULL,
    0x80004600042881ULL,
    0x4040008040800020ULL,
    0x440003000200801ULL,
    0x4200011004500ULL,
    0x188020010100100ULL,
    0x14800401802800ULL,
    0x2080040080800200ULL,
    0x124080204001001ULL,
    0x200046502000484ULL,
    0x480400080088020ULL,
    0x1000422010034000ULL,
    0x30200100110040ULL,
    0x100021010009ULL,
    0x2002080100110004ULL,
    0x202008004008002ULL,
    0x20020004010100ULL,
    0x2048440040820001ULL,
    0x101002200408200ULL,
    0x40802000401080ULL,
    0x4008142004410100ULL,
    0x2060820c0120200ULL,
    0x1001004080100ULL,
    0x20c020080040080ULL,
    0x2935610830022400ULL,
    0x44440041009200ULL,
    0x280001040802101ULL,
    0x2100190040002085ULL,
    0x80c0084100102001ULL,
    0x4024081001000421ULL,
    0x20030a0244872ULL,
    0x12001008414402ULL,
    0x2006104900a0804ULL,
    0x1004081002402ULL
};

//bishop magic numbers
U64 bishop_magic_numbers[64] = {
    0x40040844404084ULL,
    0x2004208a004208ULL,
    0x10190041080202ULL,
    0x108060845042010ULL,
    0x581104180800210ULL,
    0x2112080446200010ULL,
    0x1080820820060210ULL,
    0x3c0808410220200ULL,
    0x4050404440404ULL,
    0x21001420088ULL,
    0x24d0080801082102ULL,
    0x1020a0a020400ULL,
    0x40308200402ULL,
    0x4011002100800ULL,
    0x401484104104005ULL,
    0x801010402020200ULL,
    0x400210c3880100ULL,
    0x404022024108200ULL,
    0x810018200204102ULL,
    0x4002801a02003ULL,
    0x85040820080400ULL,
    0x810102c808880400ULL,
    0xe900410884800ULL,
    0x8002020480840102ULL,
    0x220200865090201ULL,
    0x2010100a02021202ULL,
    0x152048408022401ULL,
    0x20080002081110ULL,
    0x4001001021004000ULL,
    0x800040400a011002ULL,
    0xe4004081011002ULL,
    0x1c004001012080ULL,
    0x8004200962a00220ULL,
    0x8422100208500202ULL,
    0x2000402200300c08ULL,
    0x8646020080080080ULL,
    0x80020a0200100808ULL,
    0x2010004880111000ULL,
    0x623000a080011400ULL,
    0x42008c0340209202ULL,
    0x209188240001000ULL,
    0x400408a884001800ULL,
    0x110400a6080400ULL,
    0x1840060a44020800ULL,
    0x90080104000041ULL,
    0x201011000808101ULL,
    0x1a2208080504f080ULL,
    0x8012020600211212ULL,
    0x500861011240000ULL,
    0x180806108200800ULL,
    0x4000020e01040044ULL,
    0x300000261044000aULL,
    0x802241102020002ULL,
    0x20906061210001ULL,
    0x5a84841004010310ULL,
    0x4010801011c04ULL,
    0xa010109502200ULL,
    0x4a02012000ULL,
    0x500201010098b028ULL,
    0x8040002811040900ULL,
    0x28000010020204ULL,
    0x6000020202d0240ULL,
    0x8918844842082200ULL,
    0x4010011029020020ULL
};

//Pawn attack table[kant][vakje].
U64 pawn_attacks[2][64];
//Paard attack table[vakje].
U64 knight_attacks[64];
//Koning attack table[vakje].
U64 king_attacks[64];

//Bishop attack masks[vakje].
U64 bishop_masks[64];
//Rook attack masks[vakje].
U64 rook_masks[64];

//Bishop attack table[vakje][occupencies].
U64 bishop_attacks[64][512];
//Rook attack table[vakje][occupencies].
U64 rook_attacks[64][4096];

//Alle pion moves (met zwart/wit en welk vakje).
U64 mask_pawn_attacks(int side, int square)
{
    //idk.
    U64 attacks = 0ULL;
    U64 bitboard = 0ULL;

    //Een stuk op het bord zetten.
    set_bit(bitboard, square);

    //Als wit aan zet.
    if (!side)
    {
        //Vakje +7 is het vakje linksboven en vakje +9 is het vakje rechtsboven. Dat zijn de plekken die een witte pion kan aanvallen. Not_a_file en not_h_file zijn omdat de pion niet naar links kan slaan als die al helemaal links staat.
        if ((bitboard >> 7) & not_a_file) attacks |= (bitboard >> 7);
        if ((bitboard >> 9) & not_h_file) attacks |= (bitboard >> 9);
    }
    //Als zwart aan zet.
    else
    {
        //Vakje -7 is het vakje rechtsonder en vakje -9 is het vakje linksboven. Dat zijn de plekken die een witte pion kan aanvallen. Not_a_file en not_h_file zijn omdat de pion niet naar links kan slaan als die al helemaal links staat.
        if ((bitboard << 7) & not_h_file) attacks |= (bitboard << 7);
        if ((bitboard << 9) & not_a_file) attacks |= (bitboard << 9);
    }
    //Return alle attacks.
    return attacks;
}

//Alle paard moves.
U64 mask_knight_attacks(int square)
{
    //idk.
    U64 attacks = 0Ull;
    U64 bitboard = 0ULL;

    //Een stuk op het bord zetten.
    set_bit(bitboard, square);

    //Alle kanten dat een paard op kan. Hierbij staan de nummers: 17, 15, 10 en 6 voor plekken omhoog en omlaag. Linksboven is hierbij 1 en rechtsonder plek 64.
    if ((bitboard >> 17) & not_h_file) attacks |= (bitboard >> 17);
    if ((bitboard >> 15) & not_a_file) attacks |= (bitboard >> 15);
    if ((bitboard >> 10) & not_gh_file) attacks |= (bitboard >> 10);
    if ((bitboard >> 6) & not_ab_file) attacks |= (bitboard >> 6);
    if ((bitboard << 17) & not_a_file) attacks |= (bitboard << 17);
    if ((bitboard << 15) & not_h_file) attacks |= (bitboard << 15);
    if ((bitboard << 10) & not_ab_file) attacks |= (bitboard << 10);
    if ((bitboard << 6) & not_gh_file) attacks |= (bitboard << 6);

    //Return alle attacks.
    return attacks;
}

//Alle koning moves.
U64 mask_king_attacks(int square)
{
    //idk
    U64 attacks = 0ULL;
    U64 bitboard = 0ULL;

    //Een stuk op het bord zetten.
    set_bit(bitboard, square);

    //Alle kanten dat een koning op kan. Hierbij staan de nummers: 8, 9, 7 en 1 voor plekken omhoog en omlaag. Linksboven is hierbij 1 en rechtsonder plek 64.
    if (bitboard >> 8) attacks |= (bitboard >> 8);
    if ((bitboard >> 9) & not_h_file) attacks |= (bitboard >> 9);
    if ((bitboard >> 7) & not_a_file) attacks |= (bitboard >> 7);
    if ((bitboard >> 1) & not_h_file) attacks |= (bitboard >> 1);
    if (bitboard << 8) attacks |= (bitboard << 8);
    if ((bitboard << 9) & not_a_file) attacks |= (bitboard << 9);
    if ((bitboard << 7) & not_h_file) attacks |= (bitboard << 7);
    if ((bitboard << 1) & not_a_file) attacks |= (bitboard << 1);

    //Return alle attacks.
    return attacks;
}
//Alle bishop moves.
U64 mask_bishop_attacks(int square)
{
    U64 attacks = 0ULL;

    //Ranks (r) & files (f).
    int r, f;

    //Init target Ranks (r) & files (f).
    int tr = square / 8;
    int tf = square % 8;

    //Waar kan bishop staan. Hierbij staan de nummers voor plekken waar de bishop naar toe kan gaan (r<=6 zodat hij niet uit het bord gaat). Linksboven is hierbij 1 en rechtsonder plek 64.
    for (r = tr + 1, f = tf + 1; r <= 6 && f <= 6; r++, f++) attacks |= (1ULL << (r * 8 + f));
    for (r = tr - 1, f = tf + 1; r >= 1 && f <= 6; r--, f++) attacks |= (1ULL << (r * 8 + f));
    for (r = tr + 1, f = tf - 1; r <= 6 && f >= 1; r++, f--) attacks |= (1ULL << (r * 8 + f));
    for (r = tr - 1, f = tf - 1; r >= 1 && f >= 1; r--, f--) attacks |= (1ULL << (r * 8 + f));

    return attacks;
}
//Alle rook moves.
U64 mask_rook_attacks(int square)
{
    //Resultaat van aanval.
    U64 attacks = 0ULL;

    //Ranks & files.
    int r, f;

    //Target ranks & files.
    int tr = square / 8;
    int tf = square % 8;

    //Waar kan rook staan.
    for (r = tr + 1; r <= 6; r++) attacks |= (1ULL << (r * 8 + tf));
    for (r = tr - 1; r >= 1; r--) attacks |= (1ULL << (r * 8 + tf));
    for (f = tf + 1; f <= 6; f++) attacks |= (1ULL << (tr * 8 + f));
    for (f = tf - 1; f >= 1; f--) attacks |= (1ULL << (tr * 8 + f));

    return attacks;
}
//Generate bishop attacks on the fly (zijkanten niet skippen).
U64 bishop_attacks_on_the_fly(int square, U64 block)
{
    U64 attacks = 0ULL;

    //Ranks & files.
    int r, f;

    //Init target ranks & files.
    int tr = square / 8;
    int tf = square % 8;

    //Generate bishop attacks.
    for (r = tr + 1, f = tf + 1; r <= 7 && f <= 7; r++, f++)
    {
        attacks |= (1ULL << (r * 8 + f));
        if ((1ULL << (r * 8 + f)) & block) break;
    }
    for (r = tr - 1, f = tf + 1; r >= 0 && f <= 7; r--, f++)
    {
        attacks |= (1ULL << (r * 8 + f));
        if ((1ULL << (r * 8 + f)) & block) break;
    }
    for (r = tr + 1, f = tf - 1; r <= 7 && f >= 0; r++, f--)
    {
        attacks |= (1ULL << (r * 8 + f));
        if ((1ULL << (r * 8 + f)) & block) break;
    }
    for (r = tr - 1, f = tf - 1; r >= 0 && f >= 0; r--, f--)
    {
        attacks |= (1ULL << (r * 8 + f));
        if ((1ULL << (r * 8 + f)) & block) break;
    }

    return attacks;
}

//Generate rook attacks on the fly (zijkanten niet skippen).
U64 rook_attacks_on_the_fly(int square, U64 block)
{
    //Result attacks.
    U64 attacks = 0ULL;

    //Ranks & files.
    int r, f;
    int tr = square / 8;
    int tf = square % 8;

    //Generate rook attacks.
    for (r = tr + 1; r <= 7; r++)
    {
        attacks |= (1ULL << (r * 8 + tf));
        if ((1ULL << (r * 8 + tf)) & block) break;
    }
    for (r = tr - 1; r >= 0; r--)
    {
        attacks |= (1ULL << (r * 8 + tf));
        if ((1ULL << (r * 8 + tf)) & block) break;
    }
    for (f = tf + 1; f <= 7; f++)
    {
        attacks |= (1ULL << (tr * 8 + f));
        if ((1ULL << (tr * 8 + f)) & block) break;
    }
    for (f = tf - 1; f >= 0; f--)
    {
        attacks |= (1ULL << (tr * 8 + f));
        if ((1ULL << (tr * 8 + f)) & block) break;
    }

    return attacks;
}

void init_leapers_attacks()
{
    //Loop alle 64 vakjes zodat elk vakje is geweest.
    for (int square = 0; square < 64; square++)
    {
        //Mask elk vakje dat wordt aangevallen door een pion appart voor elk vakje van wit.
        pawn_attacks[white][square] = mask_pawn_attacks(white, square);
        //Mask elk vakje dat wordt aangevallen door een pion appart voor elk vakje van zwart.
        pawn_attacks[black][square] = mask_pawn_attacks(black, square);
        //Mask elk vakje dat wordt aangevallen door een paard appart voor elk vakje.
        knight_attacks[square] = mask_knight_attacks(square);
        //Mask elk vakje dat wordt aangevallen door een koning appart voor elk vakje.
        king_attacks[square] = mask_king_attacks(square);
    }
}

//Alle mogelijke manieren om een attack mask te hebben.
U64 set_occupancy(int index, int bits_in_mask, U64 attack_mask)
{
    U64 occupancy = 0ULL;

    //Loop het aantal keer als bits in een mask.
    for (int count = 0; count < bits_in_mask; count++)
    {
        //Square = eerste bit van linksboven naar rechtsonder.
        int square = get_ls1b_index(attack_mask);

        //Weghalen bit.
        pop_bit(attack_mask, square);

        //Lefshift 1 met count.
        if (index & (1 << count))
        {
            occupancy |= (1ULL << square);
        }
    }
    //return occupancy
    return occupancy;
}


/*****************************************\

                  MAGICS

\*****************************************/
//Het vinden van magic number
U64 find_magic_number(int square, int relevant_bits, int bishop)
{
    //init occupancy array
    U64 occupancies[4096];

    //init attack tables
    U64 attacks[4096];

    //init used attacks
    U64 used_attacks[4096];


    //Als attack_mask = bishop, dan mask_bishop_attacks. Anders mask_rook_attacks.
    U64 attack_mask = bishop ? mask_bishop_attacks(square) : mask_rook_attacks(square);

    //init occupancy indicies
    int occupancy_indicies = 1 << relevant_bits;

    //loop over occupancy indicies (welke occupancies zijn mogelijk)
    for (int index = 0; index < occupancy_indicies; index++)
    {
        //init occupancies
        occupancies[index] = set_occupancy(index, relevant_bits, attack_mask);

        //init attacks: Als attacks[index] = bishop, dan bishop attacks, anders rook attacks.
        attacks[index] = bishop ? bishop_attacks_on_the_fly(square, occupancies[index]) : rook_attacks_on_the_fly(square, occupancies[index]);
    }

    //test magic numbers loop
    for (int random_count = 0; random_count < 100000000; random_count++)
    {
        // generate magic number canditate --> na tests moet het blijken of het de echte is
        U64 magic_number = generate_magic_number();

        // skip inappropriate magic numebrs
        if (count_bits((attack_mask * magic_number) & 0xFF00000000000000) < 6) continue;

        //init used attacks
        memset(used_attacks, 0ULL, sizeof(used_attacks));

        //init index & fail flag
        int index, fail;

        //test magic index loop
        for (index = 0, fail = 0; !fail && index < occupancy_indicies; index++)
        {
            //init magic index
            int magic_index = (int)((occupancies[index] * magic_number) >> (64 - relevant_bits));

            //if magic index works
            if (used_attacks[magic_index] == 0ULL)
                //init used attacks
                used_attacks[magic_index] = attacks[index];
            //otherwise
            else if (used_attacks[magic_index] != attacks[index])
                //magic index doesnt work
                fail = 1;
        }
        //if magic number works -->
        if (!fail)
            return magic_number;
    }
    //if magic number doesnt work
    printf("  Magic number fails!");
    return 0ULL;
}
//init magic numbers
void init_magic_numbers()
{
    // loop over 64 bit squares
    for (int square = 0; square < 64; square++)
    {
        //init rook magic numbers
        printf("0x%llxULL\n", find_magic_number(square, rook_relevant_bits[square], rook));
    }
    // duidelijk verschil tussen magic numbers
    printf("\n\n\n");
    for (int square = 0; square < 64; square++)
    {
        printf("0x%llxULL\n", find_magic_number(square, bishop_relevant_bits[square], bishop));
    }
}
//Init sliders attack table.
void init_sliders_attacks(int bishop)
{
    //Loop over alle 64 vakjes.
    for (int square = 0; square < 64; square++)
    {
        //Init bishop & rook masks.
        bishop_masks[square] = mask_bishop_attacks(square);
        rook_masks[square] = mask_rook_attacks(square);

        //Init current mask. Als bishop, dan bishop masks. Als geen bishop, dan rook masks.
        U64 attack_mask = bishop ? bishop_masks[square] : rook_masks[square];

        //Init occupancy_indicies.
        int occupancy_indicies = (1 << count_bits(attack_mask));

        //Loop alle occupency indicies.
        for (int index = 0; index < occupancy_indicies; index++)
        {
            //Bishop
            if (bishop)
            {
                //Init current occupency
                U64 occupancy = set_occupancy(index, bishop_relevant_bits[square], attack_mask);
                //Init current index
                int magic_index = (occupancy * bishop_magic_numbers[square]) >> (64 - bishop_relevant_bits[square]);
                //Init bishop attacks
                bishop_attacks[square][magic_index] = bishop_attacks_on_the_fly(square, occupancy);
            }
            //rook
            else
            {
                //Init current occupency
                U64 occupancy = set_occupancy(index, rook_relevant_bits[square], attack_mask);
                //Init current index
                int magic_index = (occupancy * rook_magic_numbers[square]) >> (64 - rook_relevant_bits[square]);
                //Init rook attacks
                rook_attacks[square][magic_index] = rook_attacks_on_the_fly(square, occupancy);
            }
        }
    }
}

//Bishop attacks krijgen. Dit zijn nu echt de bits die de bishop aanvalt.
static inline U64 get_bishop_attacks(int square, U64 occupancy)
{
    //Als er een bishop op een vakje staat.
    occupancy &= bishop_masks[square];
    //Vakje maal magic number.
    occupancy *= bishop_magic_numbers[square];
    //Bits rightshifted met 64-aantal relevant bits.
    occupancy >>= 64 - bishop_relevant_bits[square];

    //Krijg bishop attacks
    return bishop_attacks[square][occupancy];
}

//Toren attacks krijgen. Dit zijn nu echt de bits die de toren aanvalt.
static inline U64 get_rook_attacks(int square, U64 occupancy)
{
    //Als er een toren op een vakje staat
    occupancy &= rook_masks[square];
    //Vakje maal magic number.
    occupancy *= rook_magic_numbers[square];
    //Bits rightshifted met 64-aantal relevant bits.
    occupancy >>= 64 - rook_relevant_bits[square];

    //Krijg toren attacks.
    return rook_attacks[square][occupancy];
}

//Koningin attacks krijgen. Dit zijn nu echt de bits die de toren aanvalt.
static inline U64 get_queen_attacks(int square, U64 occupancy)
{
    // init result attacks bitboard
    U64 queen_attacks = 0ULL;
    // init bishop occupancies
    U64 bishop_occupancy = occupancy;
    // init rook occupancies
    U64 rook_occupancy = occupancy;
    // get bishop attacks assuming current board occupancy
    bishop_occupancy &= bishop_masks[square];
    bishop_occupancy *= bishop_magic_numbers[square];
    bishop_occupancy >>= 64 - bishop_relevant_bits[square];
    // get bishop attacks
    queen_attacks = bishop_attacks[square][bishop_occupancy];
    // get rook attacks assuming current board occupancy
    rook_occupancy &= rook_masks[square];
    rook_occupancy *= rook_magic_numbers[square];
    rook_occupancy >>= 64 - rook_relevant_bits[square];
    // get rook attacks
    queen_attacks |= rook_attacks[square][rook_occupancy];
    // return queen attacks
    return queen_attacks;
}

/**************

Encoding moves

***************/

/* Dit zijn het aantal bits dat nodig is per zet of slaan en ook in hexidecimal. Er zijn bv 64 source squares. 6 bits zorgen daarvoor (2^6=64),
verder ook 64 target squares. 12 verschillende stukken wit en zwart samen, hiervoor zijn 4 bits nodig, 2^4 = 16 maar 2^3 is te weinig. etc.

          binary move bits                               hexidecimal constants

    0000 0000 0000 0000 0011 1111    source square       0x3f
    0000 0000 0000 1111 1100 0000    target square       0xfc0
    0000 0000 1111 0000 0000 0000    piece               0xf000
    0000 1111 0000 0000 0000 0000    promoted piece      0xf0000
    0001 0000 0000 0000 0000 0000    capture flag        0x100000
    0010 0000 0000 0000 0000 0000    double push flag    0x200000
    0100 0000 0000 0000 0000 0000    enpassant flag      0x400000
    1000 0000 0000 0000 0000 0000    castling flag       0x800000
*/

//Encode move. Backslash omdat meerdere lines code bij elkaar horen??
#define encode_move(source, target, piece, promoted, capture, doublep, enpassant, castling) \
    (source << 0) | (target << 6) | (piece << 12) | (promoted << 16) | (capture << 20) | (doublep << 21) | (enpassant << 22) | (castling << 23)
    //<<6 is 6 naar links want normaal begint het rechts en de 1tjes staan 6 naar links voor target zoals hierboven te zien. Voor de rest ook zo. Vid 27 extra uitleg.

//Define shortcuts voor later, de move & hexidecimal staat voor de 1en aan het begin van dit hoofdstuk "encoding ". Vid 27 extra uitleg.
//"&" is een bitwise operation voor alleen 1 als beide 1 zijn. Hierdoor krijg je alleen de source bij source en niet andere informatie erbij.
#define get_move_source(move) (move & 0x3f)
#define get_move_target(move) ((move & 0xfc0) >> 6)
#define get_move_piece(move) ((move & 0xf000) >> 12)
#define get_move_promoted(move) ((move & 0xf0000) >> 16)
#define get_move_capture(move) (move & 0x100000)
#define get_move_double(move) (move & 0x200000)
#define get_move_enpassant(move) (move & 0x400000)
#define get_move_castling(move) (move & 0x800000)

//movelist structure
typedef struct {
    //moves
    int moves[256];
    // Move count (ofwel het bijhouden van index van de move)
    int count;

} moves;

//Toevoegen van moves aan de movelist.
static inline void add_move(moves* move_list, int move)
{
    //Store moves.
    move_list->moves[move_list->count] = move;
    //Vergroot move count.
    move_list->count++;
}

//Promoted pieces, voor wit en zwart beide kleine letters.
char promoted_pieces[] = {
    [Q] = 'q',
    [R] = 'r',
    [B] = 'b',
    [N] = 'n',
    [q] = 'q',
    [r] = 'r',
    [b] = 'b',
    [n] = 'n'
};

//Print move (UCI purposes).
void print_move(int move)
{
    //Als promoted, print met promotion.
    if (get_move_promoted(move))
        printf("%s%s%c",
            square_to_coordinates[get_move_source(move)],
            square_to_coordinates[get_move_target(move)],
            promoted_pieces[get_move_promoted(move)]);
    //Anders, print zonder promotion.
    else
        printf("%s%s",
            square_to_coordinates[get_move_source(move)],
            square_to_coordinates[get_move_target(move)]);
}
//Print move list (voor debuggen).
void print_move_list(moves* move_list)
{
    //Do niks bij een lege move list.
    if (!move_list->count)
    {
        //Print geen zetten gevonden.
        printf("\n  No moves found!\n\n");
        return;
    }
    printf("\n  move    piece   capture   double    enpass    castling\n\n");
    //loop over moves within move list
    for (int move_count = 0; move_count < move_list->count; move_count++)
    {
        //init move
        int move = move_list->moves[move_count];

        #ifdef WIN64
        //print move
        printf("  %s%s%c   %c       %d         %d         %d         %d\n",
            square_to_coordinates[get_move_source(move)],
            square_to_coordinates[get_move_target(move)],
            get_move_promoted(move) ? promoted_pieces[get_move_promoted(move)] : ' ',
            ascii_pieces[get_move_piece(move)],
            get_move_capture(move) ? 1 : 0,
            get_move_double(move) ? 1 : 0,
            get_move_enpassant(move) ? 1 : 0,
            get_move_castling(move) ? 1 : 0);
        #else
            // print move
            printf("     %s%s%c   %s         %d         %d         %d         %d\n", square_to_coordinates[get_move_source(move)],
                                                                                  square_to_coordinates[get_move_target(move)],
                                                                                  get_move_promoted(move) ? promoted_pieces[get_move_promoted(move)] : ' ',
                                                                                  unicode_pieces[get_move_piece(move)],
                                                                                  get_move_capture(move) ? 1 : 0,
                                                                                  get_move_double(move) ? 1 : 0,
                                                                                  get_move_enpassant(move) ? 1 : 0,
                                                                                  get_move_castling(move) ? 1 : 0);
        #endif
    }

    //Print aantal zetten
    printf("\n\n     Total number of moves: %d\n\n", move_list->count);

}

#define copy_board()                                                        \
    U64 bitboards_copy[12], occupancies_copy[3];                            \
    int side_copy, enpassant_copy, castle_copy, fifty_copy;                 \
    memcpy(bitboards_copy, bitboards, 96);                                  \
    memcpy(occupancies_copy, occupancies, 24);                              \
    side_copy = side, enpassant_copy = enpassant, castle_copy = castle;     \
    fifty_copy = fifty;                                                     \
    U64 hash_key_copy = hash_key;                                           \

#define take_back()                                                         \
    memcpy(bitboards, bitboards_copy, 96);                                  \
    memcpy(occupancies, occupancies_copy, 24);                              \
    side = side_copy, enpassant = enpassant_copy, castle = castle_copy;     \
    fifty = fifty_copy;                                                   \
    hash_key = hash_key_copy                                                \


/**************

Move Gen

***************/
//Of een vak wordt aangevallen door de gegeven kant (of wit of zwart): belangrijk voor snelheid, want illegale moves worden niet berekend
static inline int is_square_attacked(int square, int side)
{
    //De vakken die worden aangevallen door witte pion
    if ((side == white) && (pawn_attacks[black][square] & bitboards[P])) return 1;
    //De vakken die worden aangevallen door zwarte pion
    if ((side == black) && (pawn_attacks[white][square] & bitboards[p])) return 1;
    //De vakken die worden aangevallen door paard wit of zwart
    if (knight_attacks[square] & ((!side) ? bitboards[N] : bitboards[n])) return 1;
    //De vakken die worden aangevallen door loper wit en zwart
    if (get_bishop_attacks(square, occupancies[both]) & ((!side) ? bitboards[B] : bitboards[b])) return 1;
    //De vakken die worden aangevallen door toren wit of zwart
    if (get_rook_attacks(square, occupancies[both]) & ((!side) ? bitboards[R] : bitboards[r])) return 1;
    //De vakken die worden aangevallen door koningin wit of zwart
    if (get_queen_attacks(square, occupancies[both]) & ((!side) ? bitboards[Q] : bitboards[q])) return 1;

    //De vakken die worden aangevallen door koning (wit/zwart)
    if (king_attacks[square] & ((!side) ? bitboards[K] : bitboards[k])) return 1;
    //Als niks het aanvalt
    return 0;
}
//Het printen van de aangevallen vakjes.
void print_attacked_squares(int side)
{
    //Nieuwe regel.
    printf("\n");
    //Loop over de rijen.
    for (int rank = 0; rank < 8; rank++)
    {
        //Loop over bord kollommen.
        for (int file = 0; file < 8; file++)
        {
            //Convert f&r --> square.
            int square = rank * 8 + file;
            //Print files (als file =/ 0, dan -->
            if (!file)
            {
                printf("  %d  ", 8 - rank);
            }
            //Checken of het vakje wordt aangevallen.
            printf("%d ", is_square_attacked(square, side) ? 1 : 0);
        }
        //Nieuwe lijn elke rij.
        printf("\n");
    }
    //Print rijen.
    printf("\n     a b c d e f g h\n\n");
}

//Soorten zetten.
enum { all_moves, only_captures };

//Castling rights.
const int castling_rights[64] = {
     7, 15, 15, 15,  3, 15, 15, 11,
    15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15,
    13, 15, 15, 15, 12, 15, 15, 14
};

//
static inline int make_move(int move, int move_flag)
{
    //Zet zonder slaan.
    if (move_flag == all_moves)
    {
        //Kopieer bord.
        copy_board();

        //Alles dat bij een zet komt kijken.
        int source_square = get_move_source(move);
        int target_square = get_move_target(move);
        int piece = get_move_piece(move);
        int promoted = get_move_promoted(move);
        int capture = get_move_capture(move);
        int double_push = get_move_double(move);
        int enpass = get_move_enpassant(move);
        int castling = get_move_castling(move);

        //Verzet een stuk
        //Maak een bit een 0.
        pop_bit(bitboards[piece], source_square);
        //Maak een bit een 1.
        set_bit(bitboards[piece], target_square);

        //Hash piece (remove piece from source square and move to target square)
        hash_key ^= piece_keys[piece][source_square];
        hash_key ^= piece_keys[piece][target_square];

        // increment fifty move rule counter
        fifty++;

         // if pawn moved
        if (piece == P || piece == p)
            // reset fifty move rule counter
            fifty = 0;

        //Als iets geslagen wordt.
        if (capture)
        {
             // reset fifty move rule counter
            fifty = 0;

            //Variables.
            int start_piece, end_piece;
            //Als wit aan zet.
            if (side == white)
            {
                //Loop zwarte stukken
                start_piece = p;
                end_piece = k;
            }
            //Als zwart aan zet.
            else
            {
                //Loop witte stukken
                start_piece = P;
                end_piece = K;
            }
            //Loop stukken op bord.
            for (int bb_piece = start_piece; bb_piece <= end_piece; bb_piece++)
            {
                //Als een stuk op het aangevallen vakje staat moet die worden verwijderd (wordt geslagen).
                if (get_bit(bitboards[bb_piece], target_square))
                {
                    //Verwijder bit (slaan).
                    pop_bit(bitboards[bb_piece], target_square);

                    //Remove the piece from hash key
                    hash_key ^= piece_keys[bb_piece][target_square];
                    break;
                }
            }
        }
        //Als promotie.
        if (promoted)
        {
            //Verwijder pion als wit dan P, als zwart dan p.
            pop_bit(bitboards[(side == white) ? P : p], target_square);

            //Als wit aan zet
            if(side == white)
            {
                //Verwijder pion
                pop_bit(bitboards[P], target_square);

                //Verwijder pion van hash key
                hash_key ^= piece_keys[P][target_square];
            }

            //Als zwart aan zet
            else
            {
                //Verwijder pion
                pop_bit(bitboards[p], target_square);

                //Verwijder pion van hash key
                hash_key ^= piece_keys[p][target_square];
            }

            //Zet een nieuw stuk neer (meestal koningin, het promoted piece).
            set_bit(bitboards[promoted], target_square);

            //Voeg de promoted_piece toe aan de hash key
            hash_key ^= piece_keys[promoted][target_square];
        }
        //Als enpassant.
        if (enpass)
        {
            (side == white) ?
                //Als wit, popbit +8.
                pop_bit(bitboards[p], target_square + 8) :
                //Als zwart, popbit -8.
                pop_bit(bitboards[P], target_square - 8);

                //Wit aan zet
                if (side==white)
                {
                    //Verwijder captured pawn
                    pop_bit(bitboards[p], target_square + 8);

                    //Verwijder pion van hash key
                    hash_key ^= piece_keys[p][target_square + 8];
                }

                //Zwart aan zet
                else
                {
                    //Verwijder captured pawn
                    pop_bit(bitboards[P], target_square - 8);

                    //Verwijder pion van hash key
                    hash_key ^= piece_keys[P][target_square - 8];
                }
        }

        //hash enpassant (verwijder enpassant square van hash key)
        if (enpassant != no_sq) hash_key ^= enpassant_keys[enpassant];

        //Zet enpassant naar niks want na een double pawn push wordt het een vakje en een zet verder kan dat niet meer.
        enpassant = no_sq;

        //Double pawn push.
        if (double_push)
        {
                /*(side == white) ?
                //Als wit aan zet is, dan enpassant vakje +8.
                (enpassant = target_square + 8) :
                //Als zwart aan zet is, dan enpassant vakje -8.
                (enpassant = target_square - 8);*/

                //Wit aan zet
                if (side==white)
                {
                    //Set enpassent square
                    enpassant = target_square + 8;

                    //hash enpassent
                    hash_key ^= enpassant_keys[target_square + 8];
                }

                //Zwart aan zet
                else
                {
                    //Set enpassent square
                    enpassant = target_square - 8;

                    //hash enpassent
                    hash_key ^= enpassant_keys[target_square - 8];
                }
        }
        //Castling
        if (castling)
        {
            //Target_square
            switch (target_square)
            {
                //Als target_square = g1.
            case (g1):
                //Verwijder toren op h1 en zet op f1
                pop_bit(bitboards[R], h1);
                set_bit(bitboards[R], f1);

                //Hash rook
                hash_key ^= piece_keys[R][h1];
                hash_key ^= piece_keys[R][f1];
                break;
                //Als target_square = c1.
            case (c1):
                //Verwijder toren op a1 en zet op d1
                pop_bit(bitboards[R], a1);
                set_bit(bitboards[R], d1);

                //Hash rook
                hash_key ^= piece_keys[R][a1];
                hash_key ^= piece_keys[R][d1];
                break;
                //Als target_square = g8.
            case (g8):
                //Verwijder toren op h8 en zet op f8
                pop_bit(bitboards[r], h8);
                set_bit(bitboards[r], f8);

                //Hash rook
                hash_key ^= piece_keys[r][h8];
                hash_key ^= piece_keys[r][f8];
                break;
                //Als target_square = c8.
            case (c8):
                //Verwijder toren op a8 en zet op d8
                pop_bit(bitboards[r], a8);
                set_bit(bitboards[r], d8);

                //Hash rook
                hash_key ^= piece_keys[r][a8];
                hash_key ^= piece_keys[r][d8];
                break;
            }
        }

        //Hash castling
        hash_key ^= castle_keys[castle];

        //Castle mag alleen als toren en koning nog niet hebben bewogen.
        castle &= castling_rights[source_square];
        castle &= castling_rights[target_square];

        //Hash castling
        hash_key ^= castle_keys[castle];

        //Copy occupancies.
        memset(occupancies, 0ULL, 24);
        //Loop over witte stukken bitboards en update white occupancies.
        for (int bb_piece = P; bb_piece <= K; bb_piece++) occupancies[white] |= bitboards[bb_piece];
        //Loop over witte stukken bitboards en update black occupancies.
        for (int bb_piece = p; bb_piece <= k; bb_piece++) occupancies[black] |= bitboards[bb_piece];
        //Update beide
        occupancies[both] |= occupancies[white];
        occupancies[both] |= occupancies[black];

        //Switch side
        side ^= 1;

        //Side switched dus ook hash switched
        hash_key ^= side_key;

        // ===== debug hash key incremental update ===== //

        //Maak een hask key voor updated positie
        /*U64 hash_from_scratch = generate_hash_key();

        //Als de hash key niet overeenkomt met een incrementaly updated hask key, dan stop even.
        if (hash_key != hash_from_scratch)
        {
            //voor debuggen
            printf("\n\nMake move\n");
            printf("move: "); print_move(move);
            print_board();
            printf("hash key should be: %llx\n", hash_from_scratch);
            getchar();
        }*/

        //Als koning wordt aangevallen door andere kleur.
        if (is_square_attacked((side == white) ? get_ls1b_index(bitboards[k]) : get_ls1b_index(bitboards[K]), side))
        {
            //Take back.
            take_back();
            //Illegal move.
            return 0;
        }
        //Legal move
        else return 1;
    }
    //Als de zet iets aanvalt.
    else
    {
        //Zeker weten dat de zet een aanval is.
        if (get_move_capture(move)) make_move(move, all_moves);
        //Anders niet doen.
        else return 0;
    }
}
// generate all moves
static inline void generate_moves(moves* move_list)
{
    //Init move count.
    move_list->count = 0;
    //definieer waar het stuk staat en waar het naartoe gaat
    int source_square, target_square;

    // definieer hoe het bitboard van het huidige stuk eruitziet & z'n aanvallen en maak er een kopie die wordt geloopt (meer info: vid 23 12:00=18:00)
    U64 bitboard, attacks;

    //Loop over alle stukken
    for (int piece = P; piece <= k; piece++)
    {
        //Init stuk bitboard kopie.
        bitboard = bitboards[piece];
        //Generate witte pionnen moves en witte koning rokeer moves (vid 23+)
        if (side == white)
        {
            //Als stuk is pion.
            if (piece == P)
            {
                //Loop over witte pawns op het bitboard.
                while (bitboard)
                {
                    //Waar een pion staat.
                    source_square = get_ls1b_index(bitboard);
                    //Waar een pion naartoe kan.
                    target_square = source_square - 8;

                    //Als het vakje niet op het bord staat en er geen ander stuk staat.
                    if (!(target_square < a8) && !get_bit(occupancies[both], target_square))
                    {
                        //Als het vakje op de laatste rij is, dan promotie.
                        if (source_square >= a7 && source_square <= h7)
                        {
                            //Voeg de zet toe aan de mogelijke zetten (Promoties).
                            add_move(move_list, encode_move(source_square, target_square, piece, Q, 0, 0, 0, 0));
                            add_move(move_list, encode_move(source_square, target_square, piece, R, 0, 0, 0, 0));
                            add_move(move_list, encode_move(source_square, target_square, piece, B, 0, 0, 0, 0));
                            add_move(move_list, encode_move(source_square, target_square, piece, N, 0, 0, 0, 0));
                        }

                        //Als vakje niet op laatste rij.
                        else
                        {
                            //Voeg de zet toe aan de mogelijke zetten (Pion 1 vakje naar voren).
                            add_move(move_list, encode_move(source_square, target_square, piece, 0, 0, 0, 0, 0));

                            //Voeg de zet toe aan de mogelijke zetten (Pion 2 vakjes naar voren).
                            if ((source_square >= a2 && source_square <= h2) && !get_bit(occupancies[both], target_square - 8))
                                //Voeg de zet toe aan de mogelijke zetten.
                                add_move(move_list, encode_move(source_square, target_square - 8, piece, 0, 0, 1, 0, 0));
                        }
                    }
                    //Attacks = pawn attacks van wit EN occupancies van black.
                    attacks = pawn_attacks[side][source_square] & occupancies[black];

                    //Als de pion iets aanvalt
                    while (attacks)
                    {
                        //Waar een pion naartoe kan.
                        target_square = get_ls1b_index(attacks);

                        //Als pion op laatste rij, dan promotie.
                        if (source_square >= a7 && source_square <= h7)
                        {
                            //Voeg de zet toe aan de mogelijke zetten (Aanval+promotie).
                            add_move(move_list, encode_move(source_square, target_square, piece, Q, 1, 0, 0, 0));
                            add_move(move_list, encode_move(source_square, target_square, piece, R, 1, 0, 0, 0));
                            add_move(move_list, encode_move(source_square, target_square, piece, B, 1, 0, 0, 0));
                            add_move(move_list, encode_move(source_square, target_square, piece, N, 1, 0, 0, 0));
                        }
                        //Als pion niet op laatste rij.
                        else
                        {
                            //Voeg ze zet toe aan de mogelijke zetten (Aanvallen stuk).
                            add_move(move_list, encode_move(source_square, target_square, piece, 0, 1, 0, 0, 0));
                        }
                        //Haal de pion weg zodat de zetten voor volgende pion kunnen worden berekend.
                        pop_bit(attacks, target_square);
                    }

                    //Als enpassant = een vakje.
                    if (enpassant != no_sq)
                    {
                        //enpassant attacks = pawn attacks EN enpassant vakje.
                        U64 enpassant_attacks = pawn_attacks[side][source_square] & (1ULL << enpassant);
                        //Als enpassant attack kan.
                        if (enpassant_attacks)
                        {
                            //Enpassant slaan.
                            int target_enpassant = get_ls1b_index(enpassant_attacks);
                            //Voeg de zet toe aan de mogelijke zetten (Enpassant slaan).
                            add_move(move_list, encode_move(source_square, target_enpassant, piece, 0, 1, 0, 1, 0));
                        }
                    }
                    //Haal de least significant bit weg.
                    pop_bit(bitboard, source_square);
                }
            }

            //Castling voor wit.
            if (piece == K)
            {
                //Kingside castling.
                if (castle & wk)
                {
                    //De vakjes ertussen zijn niet bezet door een stuk.
                    if (!get_bit(occupancies[both], f1) && !get_bit(occupancies[both], g1))
                    {
                        //De vakjes ertussen worden niet aangevallen door zwart.
                        if (!is_square_attacked(e1, black) && !is_square_attacked(f1, black))
                        {
                            //Voeg de zet toe aan de mogelijke zetten (Kingside castling).
                            add_move(move_list, encode_move(e1, g1, piece, 0, 0, 0, 0, 1));
                        }
                    }
                }
                //Queenside castling.
                if (castle & wq)
                {
                    //De vakjes ertussen zijn niet bezet door een stuk.
                    if (!get_bit(occupancies[both], b1) && !get_bit(occupancies[both], c1) && !get_bit(occupancies[both], d1))
                    {
                        //De vakjes ertussen worden niet aangevallen door zwart.
                        if (!is_square_attacked(d1, black) && !is_square_attacked(e1, black))
                        {
                            //Voeg de zet toe aan de mogelijke zetten (Queenside castling).
                            add_move(move_list, encode_move(e1, c1, piece, 0, 0, 0, 0, 1));
                        }
                    }
                }
            }
        }


        //Generate zwarte pion bewegingen en zwarte koning rokeer moves.
        else
        {
            //Als stuk is pion.
            if (piece == p)
            {
                //Loop alle stukken op het bitboard.
                while (bitboard)
                {
                    //Waar een pion staat.
                    source_square = get_ls1b_index(bitboard);
                    //Waar een pion naartoe kan.
                    target_square = source_square + 8;

                    //Als het vakje niet op het bord staat en er geen ander stuk staat.
                    if (!(target_square > h1) && !get_bit(occupancies[both], target_square))
                    {
                        //Als het vakje op de laatste rij staat, dan promotie.
                        if (source_square >= a2 && source_square <= h2)
                        {
                            //Voeg de zet toe aan de mogelijke zetten (Promotie).
                            add_move(move_list, encode_move(source_square, target_square, piece, q, 0, 0, 0, 0));
                            add_move(move_list, encode_move(source_square, target_square, piece, r, 0, 0, 0, 0));
                            add_move(move_list, encode_move(source_square, target_square, piece, b, 0, 0, 0, 0));
                            add_move(move_list, encode_move(source_square, target_square, piece, n, 0, 0, 0, 0));
                        }
                        //Als pion niet op 1na laatste rij staat
                        else
                        {
                            //Voeg de zet toe aan de mogelijke zetten (Pion 1 vakje naar voren).
                            add_move(move_list, encode_move(source_square, target_square, piece, 0, 0, 0, 0, 0));

                            //Als op 2e rij, kan ook 2 vakjes naar voren.
                            if ((source_square >= a7 && source_square <= h7) && !get_bit(occupancies[both], target_square + 8))
                                //Voeg de zet toe aan de mogelijke zetten (Pion 2 vakjes naar voren).
                                add_move(move_list, encode_move(source_square, target_square + 8, piece, 0, 0, 1, 0, 0));
                        }
                    }

                    //Attacks = pawn attacks van zwart EN occupancies van wit.
                    attacks = pawn_attacks[side][source_square] & occupancies[white];

                    //Als de pion iets aanvalt
                    while (attacks)
                    {
                        //Target square = eerste vakje dat aangevallen wordt vanaf linksboven.
                        target_square = get_ls1b_index(attacks);

                        //Als pion op laatste rij, dan promotie.
                        if (source_square >= a2 && source_square <= h2)
                        {
                            //Voeg de zet toe aan de mogelijke zetten (Aanvallen+promotie)
                            add_move(move_list, encode_move(source_square, target_square, piece, q, 1, 0, 0, 0));
                            add_move(move_list, encode_move(source_square, target_square, piece, r, 1, 0, 0, 0));
                            add_move(move_list, encode_move(source_square, target_square, piece, b, 1, 0, 0, 0));
                            add_move(move_list, encode_move(source_square, target_square, piece, n, 1, 0, 0, 0));
                        }
                        //Als pion niet op laatste rij.
                        else
                        {
                            //Voeg de zet toe aan de mogelijke zetten (Slaan)
                            add_move(move_list, encode_move(source_square, target_square, piece, 0, 1, 0, 0, 0));
                        }

                        //Haal de pion weg zodat de zetten voor volgende pion kunnen worden berekend.
                        pop_bit(attacks, target_square);
                    }

                    //Als enpassant = een vakje.
                    if (enpassant != no_sq)
                    {
                        //enpassant attacks = pawn attacks EN enpassant vakje.
                        U64 enpassant_attacks = pawn_attacks[side][source_square] & (1ULL << enpassant);
                        //Als enpassant attacks kan.
                        if (enpassant_attacks)
                        {
                            //Enpassant slaan.
                            int target_enpassant = get_ls1b_index(enpassant_attacks);
                            //Voeg de zet toe aan de mogelijke zetten (Enpassant slaan).
                            add_move(move_list, encode_move(source_square, target_enpassant, piece, 0, 1, 0, 1, 0));
                        }
                    }
                    //Haal de least significant bit weg.
                    pop_bit(bitboard, source_square);
                }
            }

            //Castling voor zwart.
            if (piece == k)
            {
                //Kingside castling.
                if (castle & bk)
                {
                    //De vakjes ertussen zijn niet bezet door een stuk.
                    if (!get_bit(occupancies[both], f8) && !get_bit(occupancies[both], g8))
                    {
                        //De vakjes ertussen worden niet aangevallen door zwart.
                        if (!is_square_attacked(e8, white) && !is_square_attacked(f8, white))
                        {
                            //Voeg de zet toe aan de mogelijke zetten.
                            add_move(move_list, encode_move(e8, g8, piece, 0, 0, 0, 0, 1));
                        }
                    }
                }
                //Queenside castling.
                if (castle & bq)
                {
                    //De vakjes ertussen zijn niet bezet door een stuk.
                    if (!get_bit(occupancies[both], b8) && !get_bit(occupancies[both], c8) && !get_bit(occupancies[both], d8))
                    {
                        //De vakjes ertussen worde nniet aangevallen door zwart.
                        if (!is_square_attacked(d8, white) && !is_square_attacked(e8, white))
                        {
                            //Voeg de zet toe aan de mogelijke zetten.
                            add_move(move_list, encode_move(e8, c8, piece, 0, 0, 0, 0, 1));
                        }
                    }
                }
            }
        }

        //Bepaald of het een wit of zwart paard is.
        if ((side == white) ? piece == N : piece == n)
        {
            //Zolang er een paard op het paard bitboard (kopie) is.
            while (bitboard)
            {
                //Bepaal waar de eerste knight staat van linksboven naar rechtsboven.
                source_square = get_ls1b_index(bitboard);
                //Attacks van knight is waar een knight naartoe kan bewegen, hierbij wordt rekening gehouden met zetten waarbij de knight op een stuk van zijn eigen kleur komt.
                attacks = knight_attacks[source_square] & ~occupancies[side];

                //Zolang er attack bits (of target_squares) zijn.
                while (attacks)
                {
                    //Krijg de eerste target square.
                    target_square = get_ls1b_index(attacks);
                    //Als aangevallen bit bezet is door tegenstanders kleur, dan de if, anders de else.
                    if (!get_bit(((side == white) ? occupancies[black] : occupancies[white]), target_square))
                    {
                        //Voeg de zet toe aan de mogelijke zetten.
                        add_move(move_list, encode_move(source_square, target_square, piece, 0, 0, 0, 0, 0));
                    }
                    //Voeg de zet toe aan de mogelijke zetten.
                    else add_move(move_list, encode_move(source_square, target_square, piece, 0, 1, 0, 0, 0));
                    //Verwijderd de attack zodat die naar de volgende attack gaat.
                    pop_bit(attacks, target_square);
                }
                //Verwijder bit van knight zodat die naar volgende knight gaat.
                pop_bit(bitboard, source_square);
            }
        }
        //Bepaald of het een witte of zwarte loper is.
        if ((side == white) ? piece == B : piece == b)
        {
            //Zolang er een loper op het loper bitboard (kopie) is.
            while (bitboard)
            {
                //Bepaal waar de eerste loper staat van linksboven naar rechtsonder.
                source_square = get_ls1b_index(bitboard);
                //Attacks van loper is waar een loper naartoe kan bewegen, hierbij wordt rekening gehouden met zetten waarbij de loper op een stuk van zijn eigen kleur komt.
                attacks = get_bishop_attacks(source_square, occupancies[both]) & ((side == white) ? ~occupancies[white] : ~occupancies[black]);

                //Zolang er attacks bits (of target_squares) zijn.
                while (attacks)
                {
                    //Krijg de eerste target square.
                    target_square = get_ls1b_index(attacks);
                    //Als aangevallen bit bezet is door tegenstanders kleur, dan de if, anders de else.
                    if (!get_bit(((side == white) ? occupancies[black] : occupancies[white]), target_square))
                    {
                        //Voeg de zet toe aan de mogelijke zetten.
                        add_move(move_list, encode_move(source_square, target_square, piece, 0, 0, 0, 0, 0));
                    }
                    //Voeg de zet toe aan de mogelijke zetten.
                    else add_move(move_list, encode_move(source_square, target_square, piece, 0, 1, 0, 0, 0));
                    //Verwijderd de attack zodat die naar de volgende attack gaat.
                    pop_bit(attacks, target_square);
                }
                //Verwijder bit van loper bitboard zodat die naar volgende loper gaat.
                pop_bit(bitboard, source_square);
            }
        }
        //Bepaald of het een witte of zwarte toren is.
        if ((side == white) ? piece == R : piece == r)
        {
            //Zolang er een toren op het toren bitboard (kopie) is.
            while (bitboard)
            {
                //Bepaal waar de eerste toren staat van linksboven naar rechtsonder.
                source_square = get_ls1b_index(bitboard);
                //Attacks van loper is waar een loper naartoe kan bewegen, hierbij wordt rekening gehouden met zetten waarbij de loper op een stuk van zijn eigen kleur komt.
                attacks = get_rook_attacks(source_square, occupancies[both]) & ~occupancies[side];

                //Zolang er attacks bits (of target_squares) zijn.
                while (attacks)
                {
                    //Krijg de eerste target square.
                    target_square = get_ls1b_index(attacks);
                    //Als aangevallen bit bezet is door tegenstanders kleur, dan de if, anders de else.
                    if (!get_bit(((side == white) ? occupancies[black] : occupancies[white]), target_square))
                    {
                        //Voeg de zet toe aan de mogelijke zetten.
                        add_move(move_list, encode_move(source_square, target_square, piece, 0, 0, 0, 0, 0));
                    }
                    //Voeg de zet toe aan de mogelijke zetten.
                    else add_move(move_list, encode_move(source_square, target_square, piece, 0, 1, 0, 0, 0));
                    //Verwijder de attack zodat die naar de volgende attack gaat.
                    pop_bit(attacks, target_square);
                }
                //Verwijder bit van loper bitboard zodat die naar volgende loper gaat.
                pop_bit(bitboard, source_square);
            }
        }
        //Bepaal of het een witte of zwarte koningin is.
        if ((side == white) ? piece == Q : piece == q)
        {
            //Zolagn er een koningin op het koningin bitboard (kopie) is.
            while (bitboard)
            {
                //Bepaal waar de eerste toren staat van linksboven naar rechtsonder.
                source_square = get_ls1b_index(bitboard);
                //Attacks van loper is waar een loper naartoe kan bewegen, hierbij wordt rekening gehoduen met zetten waarbij de loper op een stuk van zijn eigen kleur komt.
                attacks = get_queen_attacks(source_square, occupancies[both]) & ~occupancies[side];

                //Zolang er attacks bits (of target_squares) zijn.
                while (attacks)
                {
                    //Krijg de eerste target square.
                    target_square = get_ls1b_index(attacks);
                    //Als aangevallen bit bezet is door tegenstanders kleur, dan de if, anders de else.
                    if (!get_bit(((side == white) ? occupancies[black] : occupancies[white]), target_square))
                    {
                        //Voeg de zet toe aan de mogelijke zetten.
                        add_move(move_list, encode_move(source_square, target_square, piece, 0, 0, 0, 0, 0));
                    }
                    //Voeg de zet toe aan de mogelijke zetten.
                    else add_move(move_list, encode_move(source_square, target_square, piece, 0, 1, 0, 0, 0));
                    //Verwijder de attack zodat die naar de volgende attack gaat.
                    pop_bit(attacks, target_square);
                }
                //Verwijder bit van koningin zodat die naar de volgende koningin gaat.
                pop_bit(bitboard, source_square);
            }
        }
        //Bepaal of het een witte of zwarte koning is.
        if ((side == white) ? piece == K : piece == k)
        {
            //Zolang er een koning op het koning bitboard (kopie) is.
            while (bitboard)
            {
                //Bepaal waar de eerste toren staat van linksboven naar rechtsonder.
                source_square = get_ls1b_index(bitboard);
                //Attacks van koning is waar een koning naartoe kan bewegen, hierbij wordt rekening gehoduen met zetten waarbij de koning op een stuk van zijn eigen kleur komt.
                attacks = king_attacks[source_square] & ~occupancies[side];

                //Zolang er attacks bits (of target_squares) zijn.
                while (attacks)
                {
                    //Krijg de eerste target square.
                    target_square = get_ls1b_index(attacks);
                    //Als aangevallen bit bezet is door tegenstanders kleur, dan de if, anders de else.
                    if (!get_bit(((side == white) ? occupancies[black] : occupancies[white]), target_square))
                    {
                        //Voeg de zet toe aan de mogelijke zetten.
                        add_move(move_list, encode_move(source_square, target_square, piece, 0, 0, 0, 0, 0));
                    }
                    //Voeg de zet toe aan de mogelijke zetten.
                    else add_move(move_list, encode_move(source_square, target_square, piece, 0, 1, 0, 0, 0));
                    //Verwijder de atttack zodat die naar de volgende attack gaat.
                    pop_bit(attacks, target_square);
                }
                //Verwijder bit van koning zodat die naar de volgende koning gaat.
                pop_bit(bitboard, source_square);
            }
        }
    }
}
/**********************************\
 ==================================
               Perft
 ==================================
\**********************************/
// leaf nodes (number of positions reached during the test of the move generator at a given depth)
U64 nodes;
// perft driver
static inline void perft_driver(int depth)
{
    // reccursion escape condition
    if (depth == 0)
    {
        // increment nodes count (count reached positions)
        nodes++;
        return;
    }
    // create move list instance
    moves move_list[1];
    // generate moves
    generate_moves(move_list);
        // loop over generated moves
    for (int move_count = 0; move_count < move_list->count; move_count++)
    {
        // preserve board state
        copy_board();
        // make move
        if (!make_move(move_list->moves[move_count], all_moves))
            // skip to the next move
            continue;
        // call perft driver recursively
        perft_driver(depth - 1);
        // take back
        take_back();
        // build hash key for the updated position (after move is made) from scratch
        /*U64 hash_from_scratch = generate_hash_key();
        // in case if hash key built from scratch doesn't match
        // the one that was incrementally updated we interrupt execution
        if (hash_key != hash_from_scratch)
        {
            printf("\n\nTake back\n");
            printf("move: "); print_move(move_list->moves[move_count]);
            print_board();
            printf("hash key should be: %llx\n", hash_from_scratch);
            getchar();
        }*/
    }
}
// perft test
void perft_test(int depth)
{
    printf("\n     Performance test\n\n");
    // create move list instance
    moves move_list[1];
    // generate moves
    generate_moves(move_list);
    // init start time
    long start = get_time_ms();
    // loop over generated moves
    for (int move_count = 0; move_count < move_list->count; move_count++)
    {
        // preserve board state
        copy_board();
        // make move
        if (!make_move(move_list->moves[move_count], all_moves))
            // skip to the next move
            continue;
        // cummulative nodes
        long cummulative_nodes = nodes;
        // call perft driver recursively
        perft_driver(depth - 1);
        // old nodes
        long old_nodes = nodes - cummulative_nodes;
        // take back
        take_back();
        // print move
        printf("     move: %s%s%c  nodes: %ld\n", square_to_coordinates[get_move_source(move_list->moves[move_count])],
                                                 square_to_coordinates[get_move_target(move_list->moves[move_count])],
                                                 get_move_promoted(move_list->moves[move_count]) ? promoted_pieces[get_move_promoted(move_list->moves[move_count])] : ' ',
                                                 old_nodes);
    }
    // print results
    printf("\n    Depth: %d\n", depth);
    printf("    Nodes: %ld\n", nodes);
    printf("     Time: %ld\n\n", get_time_ms() - start);
}

/**************

EVALUATION

***************/
/*int material_score[12] = {
    100,      // white pawn score
    325,      // white knight scrore
    335,      // white bishop score
    500,      // white rook score
    975,      // white queen score
  10000,      // white king score
   -100,      // black pawn score
   -325,      // black knight scrore
   -335,      // black bishop score
   -500,      // black rook score
   -975,      // black queen score
 -10000,      // black king score
};
*/
int mg_value[12] = { 82, 337, 365, 477, 1025,  10000, -82,-337,-365,-477,-1025,-10000};
int eg_value[12] = { 94, 281, 297, 512,  936,  10000,-94,-281,-297,-512,-936,-10000};



//Vakje van engines kant naar tegenstanders kant en andersom.
const int mirror_score[128] =
{
    a1, b1, c1, d1, e1, f1, g1, h1,
    a2, b2, c2, d2, e2, f2, g2, h2,
    a3, b3, c3, d3, e3, f3, g3, h3,
    a4, b4, c4, d4, e4, f4, g4, h4,
    a5, b5, c5, d5, e5, f5, g5, h5,
    a6, b6, c6, d6, e6, f6, g6, h6,
    a7, b7, c7, d7, e7, f7, g7, h7,
    a8, b8, c8, d8, e8, f8, g8, h8
};

/* piece/sq tables */
/* values from Rofchade: http://www.talkchess.com/forum3/viewtopic.php?f=2&t=68311&start=19 */

int mg_pawn_table[64] = {
      0,   0,   0,   0,   0,   0,  0,   0,
     98, 134,  61,  95,  68, 126, 34, -11,
     -6,   7,  26,  31,  65,  56, 25, -20,
    -14,  13,   6,  21,  23,  12, 17, -23,
    -27,  -2,  -5,  12,  17,   6, 10, -25,
    -26,  -4,  -4, -10,   3,   3, 33, -12,
    -35,  -1, -20, -23, -15,  24, 38, -22,
      0,   0,   0,   0,   0,   0,  0,   0,
};

int eg_pawn_table[64] = {
      0,   0,   0,   0,   0,   0,   0,   0,
    178, 173, 158, 134, 147, 132, 165, 187,
     94, 100,  85,  67,  56,  53,  82,  84,
     32,  24,  13,   5,  -2,   4,  17,  17,
     13,   9,  -3,  -7,  -7,  -8,   3,  -1,
      4,   7,  -6,   1,   0,  -5,  -1,  -8,
     13,   8,   8,  10,  13,   0,   2,  -7,
      0,   0,   0,   0,   0,   0,   0,   0,
};

int mg_knight_table[64] = {
    -167, -89, -34, -49,  61, -97, -15, -107,
     -73, -41,  72,  36,  23,  62,   7,  -17,
     -47,  60,  37,  65,  84, 129,  73,   44,
      -9,  17,  19,  53,  37,  69,  18,   22,
     -13,   4,  16,  13,  28,  19,  21,   -8,
     -23,  -9,  12,  10,  19,  17,  25,  -16,
     -29, -53, -12,  -3,  -1,  18, -14,  -19,
    -105, -21, -58, -33, -17, -28, -19,  -23,
};

int eg_knight_table[64] = {
    -58, -38, -13, -28, -31, -27, -63, -99,
    -25,  -8, -25,  -2,  -9, -25, -24, -52,
    -24, -20,  10,   9,  -1,  -9, -19, -41,
    -17,   3,  22,  22,  22,  11,   8, -18,
    -18,  -6,  16,  25,  16,  17,   4, -18,
    -23,  -3,  -1,  15,  10,  -3, -20, -22,
    -42, -20, -10,  -5,  -2, -20, -23, -44,
    -29, -51, -23, -15, -22, -18, -50, -64,
};

int mg_bishop_table[64] = {
    -29,   4, -82, -37, -25, -42,   7,  -8,
    -26,  16, -18, -13,  30,  59,  18, -47,
    -16,  37,  43,  40,  35,  50,  37,  -2,
     -4,   5,  19,  50,  37,  37,   7,  -2,
     -6,  13,  13,  26,  34,  12,  10,   4,
      0,  15,  15,  15,  14,  27,  18,  10,
      4,  15,  16,   0,   7,  21,  33,   1,
    -33,  -3, -14, -21, -13, -12, -39, -21,
};

int eg_bishop_table[64] = {
    -14, -21, -11,  -8, -7,  -9, -17, -24,
     -8,  -4,   7, -12, -3, -13,  -4, -14,
      2,  -8,   0,  -1, -2,   6,   0,   4,
     -3,   9,  12,   9, 14,  10,   3,   2,
     -6,   3,  13,  19,  7,  10,  -3,  -9,
    -12,  -3,   8,  10, 13,   3,  -7, -15,
    -14, -18,  -7,  -1,  4,  -9, -15, -27,
    -23,  -9, -23,  -5, -9, -16,  -5, -17,
};

int mg_rook_table[64] = {
     32,  42,  32,  51, 63,  9,  31,  43,
     27,  32,  58,  62, 80, 67,  26,  44,
     -5,  19,  26,  36, 17, 45,  61,  16,
    -24, -11,   7,  26, 24, 35,  -8, -20,
    -36, -26, -12,  -1,  9, -7,   6, -23,
    -45, -25, -16, -17,  3,  0,  -5, -33,
    -44, -16, -20,  -9, -1, 11,  -6, -71,
    -19, -13,   1,  17, 16,  7, -37, -26,
};

int eg_rook_table[64] = {
    13, 10, 18, 15, 12,  12,   8,   5,
    11, 13, 13, 11, -3,   3,   8,   3,
     7,  7,  7,  5,  4,  -3,  -5,  -3,
     4,  3, 13,  1,  2,   1,  -1,   2,
     3,  5,  8,  4, -5,  -6,  -8, -11,
    -4,  0, -5, -1, -7, -12,  -8, -16,
    -6, -6,  0,  2, -9,  -9, -11,  -3,
    -9,  2,  3, -1, -5, -13,   4, -20,
};

int mg_queen_table[64] = {
    -28,   0,  29,  12,  59,  44,  43,  45,
    -24, -39,  -5,   1, -16,  57,  28,  54,
    -13, -17,   7,   8,  29,  56,  47,  57,
    -27, -27, -16, -16,  -1,  17,  -2,   1,
     -9, -26,  -9, -10,  -2,  -4,   3,  -3,
    -14,   2, -11,  -2,  -5,   2,  14,   5,
    -35,  -8,  11,   2,   8,  15,  -3,   1,
     -1, -18,  -9,  10, -15, -25, -31, -50,
};

int eg_queen_table[64] = {
     -9,  22,  22,  27,  27,  19,  10,  20,
    -17,  20,  32,  41,  58,  25,  30,   0,
    -20,   6,   9,  49,  47,  35,  19,   9,
      3,  22,  24,  45,  57,  40,  57,  36,
    -18,  28,  19,  47,  31,  34,  39,  23,
    -16, -27,  15,   6,   9,  17,  10,   5,
    -22, -23, -30, -16, -16, -23, -36, -32,
    -33, -28, -22, -43,  -5, -32, -20, -41,
};

int mg_king_table[64] = {
    -65,  23,  16, -15, -56, -34,   2,  13,
     29,  -1, -20,  -7,  -8,  -4, -38, -29,
     -9,  24,   2, -16, -20,   6,  22, -22,
    -17, -20, -12, -27, -30, -25, -14, -36,
    -49,  -1, -27, -39, -46, -44, -33, -51,
    -14, -14, -22, -46, -44, -30, -15, -27,
      1,   7,  -8, -64, -43, -16,   9,   8,
    -15,  36,  12, -54,   8, -28,  24,  14,
};

int eg_king_table[64] = {
    -74, -35, -18, -18, -11,  15,   4, -17,
    -12,  17,  14,  17,  17,  38,  23,  11,
     10,  17,  23,  15,  20,  45,  44,  13,
     -8,  22,  24,  27,  26,  33,  26,   3,
    -18,  -4,  21,  24,  27,  23,   9, -11,
    -19,  -3,  11,  21,  23,  16,   7,  -9,
    -27, -11,   4,  13,  14,   4,  -5, -17,
    -53, -34, -21, -11, -28, -14, -24, -43
};
//file masks
U64 file_masks[64];

U64 rank_masks[64];

U64 isolated_masks[64];

U64 white_passed_masks[64];
U64 black_passed_masks[64];
// extract rank from a square [square]
const int get_rank[64] =
{
    7, 7, 7, 7, 7, 7, 7, 7,
    6, 6, 6, 6, 6, 6, 6, 6,
    5, 5, 5, 5, 5, 5, 5, 5,
    4, 4, 4, 4, 4, 4, 4, 4,
    3, 3, 3, 3, 3, 3, 3, 3,
    2, 2, 2, 2, 2, 2, 2, 2,
    1, 1, 1, 1, 1, 1, 1, 1,
	0, 0, 0, 0, 0, 0, 0, 0
};

// double pawns penalty
const int opening_double_pawn_penalty = -5;
const int endgame_double_pawn_penalty = -10;

// isolated pawn penalty
const int opening_isolated_pawn_penalty = -5;
const int endgame_isolated_pawn_penalty = -15;

// king's shield bonus
const int opening_king_shield_bonus = 10;
const int endgame_king_shield_bonus = 0;

// semi open file score
const int semi_open_file_score = 10;

// open file score
const int open_file_score = 20;

// pair bonus
const int bishop_pair = 30;

//Adjustments voor waarden toren en paard naar aantal pionnen op het spel
int knight_adj[9] = { -20, -16, -12, -8, -4,  0,  4,  8, 12 };
int rook_adj[9] = { 15,  12,   9,  6,  3,  0, -3, -6, -9 };


U64 set_file_rank_mask(int file_number, int rank_number)
{
    U64 mask = 0ULL;

    for (int rank = 0; rank < 8; rank ++)
    {
        for (int file = 0; file < 8; file++)
        {
            int square = rank * 8 + file;
            if (file_number != -1) {
                    if (file == file_number)
                mask |= set_bit(mask, square);
            }
            else if(rank_number !=-1)
            {
                if (rank == rank_number)
                mask |= set_bit(mask, square);
            }

        }
    }

    return mask;
}
void init_evaluation_masks()
{
    for (int rank = 0; rank < 8; rank ++)
    {
        for (int file = 0; file < 8; file++)
        {
           int square = rank * 8 + file;
           file_masks[square]|= set_file_rank_mask(file, -1);
           //  print_bitboard(file_masks[square]);
        }
    }
    for (int rank = 0; rank < 8; rank ++)
    {
        for (int file = 0; file < 8; file++)
        {
           int square = rank * 8 + file;
           rank_masks[square]|= set_file_rank_mask(-1, rank);
           //print_bitboard(file_masks[square]);
        }
    }

    for (int rank = 0; rank < 8; rank ++)
    {
        for (int file = 0; file < 8; file++)
        {
           int square = rank * 8 + file;
           isolated_masks[square]|= set_file_rank_mask(file -1, -1);
           isolated_masks[square]|= set_file_rank_mask(file +1, -1);
           //print_bitboard(file_masks[square]);
        }
    }
    for (int rank = 0; rank < 8; rank ++)
    {
        for (int file = 0; file < 8; file++)
        {
           int square = rank * 8 + file;
           white_passed_masks[square]|= set_file_rank_mask(file -1, -1);
           white_passed_masks[square]|= set_file_rank_mask(file, -1);
           white_passed_masks[square]|= set_file_rank_mask(file +1, -1);
           //print_bitboard(file_masks[square]);

           for (int i = 0; i < (8-rank); i++)
            white_passed_masks[square] &= ~rank_masks[(7-i) * 8 + file];
        }
    }
      for (int rank = 0; rank < 8; rank ++)
    {
        for (int file = 0; file < 8; file++)
        {
           int square = rank * 8 + file;
           black_passed_masks[square]|= set_file_rank_mask(file -1, -1);
           black_passed_masks[square]|= set_file_rank_mask(file, -1);
           black_passed_masks[square]|= set_file_rank_mask(file +1, -1);
           //print_bitboard(file_masks[square]);

           for (int i = 0; i < rank; i++)
            black_passed_masks[square] &= ~rank_masks[i * 8 + file];
        }
    }
}

static inline int evaluate()
{
    //static evaluation score
    int score = 0;
    //current pieces bitboard copy
    U64 bitboard;
    // init piece & square
    int piece, square;
    //Define tellen stukken
    int Pcount = 0;
    int Ncount = 0;
    int Bcount = 0;
    int Rcount = 0;
    int Qcount = 0;
    int Kcount = 0;

    int pcount = 0;
    int ncount = 0;
    int bcount = 0;
    int rcount = 0;
    int qcount = 0;
    int kcount = 0;

    //Define opening score en endgame score
    int opening_material_score = 0;
    int endgame_material_score = 0;
    int opening_score = 0;
    int endgame_score = 0;
    int positional_score = 0;
    int opening_pawn_score = 0;
    int endgame_pawn_score = 0;

    //Define opening mobility en endgame mobility
    int opening_mobility = 0;
    int endgame_mobility = 0;
    int knight_mobility = 0;
    int bishop_mobility = 0;
    int rook_mobility = 0;
    int queen_mobility = 0;
    int king_mobility = 0;

    int double_pawns = 0;

    // loop over piece bitboards
    for (int bb_piece = P; bb_piece <= k; bb_piece++)
    {
        // init bitboard piece copy
        bitboard = bitboards[bb_piece];
        //loop over pieces within a bitboard
        while (bitboard)
        {
            //init piece
            piece = bb_piece;
            //vakje moet gelijk zijn aan de ls1b index van het bitboard
            square = get_ls1b_index(bitboard);

            //Kies stuk.
            switch (piece)
            {
                //Tel de positional score van wit per stuk erbij op.
                case P:
                    opening_score += mg_pawn_table[square];
                    endgame_score += eg_pawn_table[square];
                    // double pawn penalty
                    double_pawns = count_bits(bitboards[P] & file_masks[square]);

                    // on double pawns (tripple, etc)
                    if (double_pawns > 1)
                    {
                        opening_pawn_score += double_pawns * opening_double_pawn_penalty;
                        endgame_pawn_score += double_pawns * endgame_double_pawn_penalty;
                    }
                    // on isolated pawn
                    if ((bitboards[P] & isolated_masks[square]) == 0)
                    {
                        // give an isolated pawn penalty
                        opening_pawn_score += opening_isolated_pawn_penalty;
                        endgame_pawn_score += endgame_isolated_pawn_penalty;
                    }
                    // on passed pawn
                    if ((white_passed_masks[square] & bitboards[p]) == 0)
                    {
                        // give passed pawn bonus
                        opening_pawn_score += 0;
                        endgame_pawn_score += 0;
                    }

                    opening_material_score += mg_value[P];
                    endgame_material_score += eg_value[P];
                    Pcount++;
                    break;

                case N:
                    Ncount++;

                    opening_score += mg_knight_table[square];
                    endgame_score += eg_knight_table[square];

                    //if (Ncount = 2)
                    //    positional_score += knight_pair;

                    knight_mobility = count_bits(knight_attacks[square]);
                    opening_mobility += 4 * (knight_mobility - 4);
                    endgame_mobility += 4 * (knight_mobility - 4);

                    opening_material_score += mg_value[N];
                    endgame_material_score += eg_value[N];
                    break;

                case B:
                    Bcount++;

                    opening_score += mg_bishop_table[square];
                    endgame_score += eg_bishop_table[square];

                    //if (Bcount = 2)
                    //    positional_score += bishop_pair;

                    bishop_mobility = count_bits(get_bishop_attacks(square, occupancies[both]));
                    opening_mobility += 5 * (bishop_mobility - 7);
                    endgame_mobility += 5 * (bishop_mobility - 7);

                    opening_material_score += mg_value[B];
                    endgame_material_score += eg_value[B];
                    break;

                case R:
                    Rcount++;

                    opening_score += mg_rook_table[square];
                    endgame_score += eg_rook_table[square];

                    //if (Rcount = 2)
                    //    positional_score += rook_pair;

                    // semi open file
                    if ((bitboards[P] & file_masks[square]) == 0)
                        // add semi open file bonus
                        opening_score += semi_open_file_score;
                        endgame_score += semi_open_file_score;

                    // open file
                    if (((bitboards[P] | bitboards[p]) & file_masks[square]) == 0)
                        // add semi open file bonus
                        opening_score += open_file_score;
                        endgame_score += open_file_score;

                    rook_mobility = count_bits(get_rook_attacks(square, occupancies[both]));
                    opening_mobility += 2 * (rook_mobility - 7);
                    endgame_mobility += 4 * (rook_mobility - 7);

                    opening_material_score += mg_value[R];
                    endgame_material_score += eg_value[R];
                    break;

                case Q:
                    opening_score += mg_queen_table[square];
                    endgame_score += eg_queen_table[square];
                    Qcount++;
                    queen_mobility = count_bits(get_queen_attacks(square, occupancies[both]));
                    opening_mobility += 1 * (queen_mobility - 14);
                    endgame_mobility += 2 * (queen_mobility - 14);

                    opening_material_score += mg_value[Q];
                    endgame_material_score += eg_value[Q];
                    break;

                case K:
                    opening_score += mg_king_table[square];
                    endgame_score += eg_king_table[square];

                    // semi open file
                    if ((bitboards[P] & file_masks[square]) == 0)
                        // add semi open file penalty
                        opening_score -= semi_open_file_score;
                        endgame_score -= semi_open_file_score;

                    // semi open file
                    if (((bitboards[P] | bitboards[p]) & file_masks[square]) == 0)
                        // add semi open file penalty
                        opening_score -= open_file_score;
                        endgame_score -= open_file_score;

                         // king safety bonus
                    opening_score += count_bits(king_attacks[square] & occupancies[white]) * opening_king_shield_bonus;
                    endgame_score += count_bits(king_attacks[square] & occupancies[white]) * endgame_king_shield_bonus;

                    opening_material_score += mg_value[K];
                    endgame_material_score += eg_value[K];
                    Kcount++;
                    break;

                //Trek de positional score van wit per stuk ervanaf.
                case p:
                    opening_score -= mg_pawn_table[mirror_score[square]];
                    endgame_score -= eg_pawn_table[mirror_score[square]];

                    // double pawn penalty
                    double_pawns = count_bits(bitboards[p] & file_masks[square]);

                    // on double pawns (tripple, etc)
                    if (double_pawns > 1)
                    {
                        opening_pawn_score -= double_pawns * opening_double_pawn_penalty;
                        endgame_pawn_score -= double_pawns * endgame_double_pawn_penalty;
                    }
                    // on isolated pawnd
                    if ((bitboards[p] & isolated_masks[square]) == 0)
                    {
                        // give an isolated pawn penalty
                        opening_pawn_score -= opening_isolated_pawn_penalty;
                        endgame_pawn_score -= endgame_isolated_pawn_penalty;
                    }
                    // on passed pawn
                    if ((black_passed_masks[square] & bitboards[P]) == 0)
                    {
                        // give passed pawn bonus
                        opening_pawn_score -= 0;
                        endgame_pawn_score -= 0;
                    }

                    opening_material_score += mg_value[p];
                    endgame_material_score += eg_value[p];

                    pcount++;
                    break;

                case n:
                    ncount++;

                    opening_score -= mg_knight_table[mirror_score[square]];
                    endgame_score -= eg_knight_table[mirror_score[square]];

                    //if (ncount = 2)
                    //    positional_score -= knight_pair;

                    knight_mobility = count_bits(knight_attacks[square]);
                    opening_mobility -= 4 * (knight_mobility - 4);
                    endgame_mobility -= 4 * (knight_mobility - 4);

                    opening_material_score += mg_value[n];
                    endgame_material_score += eg_value[n];
                    break;

                case b:
                    bcount++;

                    opening_score -= mg_bishop_table[mirror_score[square]];
                    endgame_score -= eg_bishop_table[mirror_score[square]];

                    //if (bcount = 2)
                    //    positional_score -= bishop_pair;

                    bishop_mobility = count_bits(get_bishop_attacks(square, occupancies[both]));
                    opening_mobility -= 5 * (bishop_mobility - 7);
                    endgame_mobility -= 5 * (bishop_mobility - 7);

                    opening_material_score += mg_value[b];
                    endgame_material_score += eg_value[b];
                    break;

                case r:
                    rcount++;

                    opening_score -= mg_rook_table[mirror_score[square]];
                    endgame_score -= eg_rook_table[mirror_score[square]];

                    //if (rcount = 2)
                    //    positional_score -= rook_pair;

                    // semi open file
                    if ((bitboards[p] & file_masks[square]) == 0)
                        // add semi open file bonus
                        opening_score -= semi_open_file_score;
                        endgame_score -= semi_open_file_score;

                    // semi open file
                    if (((bitboards[P] | bitboards[p]) & file_masks[square]) == 0)
                        // add semi open file bonus
                        opening_score -= open_file_score;
                        endgame_score -= open_file_score;

                    rook_mobility = count_bits(get_rook_attacks(square, occupancies[both]));
                    opening_mobility -= 2 * (rook_mobility - 7);
                    endgame_mobility -= 4 * (rook_mobility - 7);

                    opening_material_score += mg_value[r];
                    endgame_material_score += eg_value[r];
                    break;

                case q:
                    opening_score -= mg_queen_table[mirror_score[square]];
                    endgame_score -= eg_queen_table[mirror_score[square]];
                    qcount++;
                    queen_mobility = count_bits(get_queen_attacks(square, occupancies[both]));
                    opening_mobility -= 1 * (queen_mobility - 14);
                    endgame_mobility -= 2 * (queen_mobility - 14);

                    opening_material_score += mg_value[q];
                    endgame_material_score += eg_value[q];
                    break;

                case k:
                    opening_score -= mg_king_table[mirror_score[square]];
                    endgame_score -= eg_king_table[mirror_score[square]];

                    // semi open file
                    if ((bitboards[p] & file_masks[square]) == 0)
                        // add semi open file penalty
                        opening_score += semi_open_file_score;
                        endgame_score += semi_open_file_score;

                    // semi open file
                    if (((bitboards[P] | bitboards[p]) & file_masks[square]) == 0)
                        // add semi open file penalty
                        opening_score += open_file_score;
                        endgame_score += open_file_score;

                        // king safety bonus
                    opening_score -= count_bits(king_attacks[square] & occupancies[black]) * opening_king_shield_bonus;
                    endgame_score -= count_bits(king_attacks[square] & occupancies[black]) * endgame_king_shield_bonus;
                    kcount++;

                    opening_material_score += mg_value[k];
                    endgame_material_score += eg_value[k];
                    break;
            }

            //Pop ls1b van kopie.
            pop_bit(bitboard, square);
        }
    }
    //printf("ADJope: %d \n ADJend: %d \n", opening_score, endgame_score);

    opening_score -= rook_adj[pcount] * rcount;
    endgame_score -= rook_adj[pcount] * rcount;
    opening_score += rook_adj[Pcount] * Rcount;
    endgame_score += rook_adj[Pcount] * Rcount;

    opening_score -= knight_adj[pcount] * ncount;
    endgame_score -= knight_adj[pcount] * ncount;
    opening_score += knight_adj[Pcount] * Ncount;
    endgame_score += knight_adj[Pcount] * Ncount;

    //printf("ADJope: %d \n ADJend: %d \n", opening_score, endgame_score);

    if (bcount == 2)
        positional_score -= bishop_pair;
    if (Bcount == 2)
        positional_score += bishop_pair;


    //Define phase dingen
    int pawn_phase = 0;
    int knight_phase = 1;
    int bishop_phase = 1;
    int rook_phase = 2;
    int queen_phase = 4;
    int total_phase = pawn_phase*16 + knight_phase*4 + bishop_phase*4 + rook_phase*4 + queen_phase*2;

    int phase = total_phase;

    phase -= Pcount * pawn_phase; // Where p is the number of white pawns currently on the board
    phase -= Ncount * knight_phase;
    phase -= Bcount * bishop_phase;
    phase -= Rcount * rook_phase;
    phase -= Qcount * queen_phase;
    phase -= pcount * pawn_phase;
    phase -= ncount * knight_phase;
    phase -= bcount * bishop_phase;
    phase -= rcount * rook_phase;
    phase -= qcount * queen_phase;

    phase = (phase * 256 + (total_phase / 2)) / total_phase;

    score += (((opening_material_score + opening_score + opening_mobility + opening_pawn_score) * (256 - phase)) + ((endgame_material_score + endgame_score + endgame_mobility + endgame_pawn_score) * phase)) / 256;
    score += positional_score;

    //printf("pawns: %d \n overig enzo: %d \n material: %d \n mobility: %d \n positional: %d \n score: %d \n",
    //      (opening_pawn_score + endgame_pawn_score) / 2, (opening_score + endgame_score) /2, (opening_material_score + endgame_material_score) / 2, (opening_mobility + endgame_mobility) / 2, positional_score, score);

    int white_total_count = 0;
    int black_total_count = 0;
    white_total_count = Pcount + Ncount + Bcount + Rcount + Qcount;
    black_total_count = bcount + ncount + bcount + rcount + qcount;

    //Voor wit gelijkspel evaluatie
    //Een loper kan zelf geen schaakmat zetten
    if (white_total_count == 1 && Bcount == 1 && black_total_count == 0)
        return 0;

    //Een paard kan zelf geen schaakmat zetten
    if (white_total_count == 1 && Ncount == 1 && black_total_count == 0)
        return 0;

    //Twee paarden kunnen geen schaakmat zetten
    if (white_total_count == 2 && Ncount == 2 && black_total_count == 0)
        return 0;

    //Toren tegen paard is gelijkspel ish dus score verkleinen
    if (white_total_count == 1 && Rcount == 1 && black_total_count == 1 && ncount == 1)
        score /= 2;

    //Toren tegen loper is gelijkspel ish dus score verkleinen
    if (white_total_count == 1 && Rcount == 1 && black_total_count == 1 && bcount == 1)
        score /= 2;

    //Toren en loper tegen toren is meestal gelijkspel
    if (white_total_count == 2 && Rcount == 1 && Bcount == 1 && black_total_count == 1 && rcount == 1)
        score /= 2;

    //Toren en paard tegen toren is meestal gelijkspel
    if (white_total_count == 2 && Rcount == 1 && Ncount == 1 && black_total_count == 1 && rcount == 1)
        score /= 2;

    //Voor zwart gelijkspel evaluatie
    //Een loper kan zelf geen schaakmat zetten
    if (black_total_count == 1 && bcount == 1 && white_total_count == 0)
        return 0;

    //Een paard kan zelf geen schaakmat zetten
    if (black_total_count == 1 && ncount == 1 && white_total_count == 0)
        return 0;

    //Twee paarden kunnen geen schaakmat zetten
    if (black_total_count == 2 && ncount == 2 && white_total_count == 0)
        return 0;

    //Toren tegen paard is gelijkspel ish dus score verkleinen
    if (black_total_count == 1 && rcount == 1 && white_total_count == 1 && Ncount == 1)
        score /= 2;

    //Toren tegen loper is gelijkspel ish dus score verkleinen
    if (black_total_count == 1 && rcount == 1 && white_total_count == 1 && Bcount == 1)
        score /= 2;

    //Toren en loper tegen toren is meestal gelijkspel
    if (black_total_count == 2 && rcount == 1 && Rcount == 1 && white_total_count == 1 && Rcount == 1)
        score /= 2;

    //Toren en paard tegen toren is meestal gelijkspel
    if (black_total_count == 2 && rcount == 1 && ncount == 1 && white_total_count == 1 && Rcount == 1)
        score /= 2;

    return (side == white) ? score : -score;
}



//Bound voor mating scores
#define infinity 50000
#define mate_value 49000
#define mate_score 48000

//Most valuable victim - Least valuable attacker tabel.
static int mvv_lva[12][12] = {
    105, 205, 305, 405, 505, 605,  105, 205, 305, 405, 505, 605,
    104, 204, 304, 404, 504, 604,  104, 204, 304, 404, 504, 604,
    103, 203, 303, 403, 503, 603,  103, 203, 303, 403, 503, 603,
    102, 202, 302, 402, 502, 602,  102, 202, 302, 402, 502, 602,
    101, 201, 301, 401, 501, 601,  101, 201, 301, 401, 501, 601,
    100, 200, 300, 400, 500, 600,  100, 200, 300, 400, 500, 600,

    105, 205, 305, 405, 505, 605,  105, 205, 305, 405, 505, 605,
    104, 204, 304, 404, 504, 604,  104, 204, 304, 404, 504, 604,
    103, 203, 303, 403, 503, 603,  103, 203, 303, 403, 503, 603,
    102, 202, 302, 402, 502, 602,  102, 202, 302, 402, 502, 602,
    101, 201, 301, 401, 501, 601,  101, 201, 301, 401, 501, 601,
    100, 200, 300, 400, 500, 600,  100, 200, 300, 400, 500, 600
};
// constante voor de max PLY in Ã©Ã©n search
#define MAX_PLY 64
// killer moves [id][ply]
int killer_moves[2][MAX_PLY];

// history moves [id][ply]
int history_moves[12][64];

int pv_length[MAX_PLY];
int pv_table[MAX_PLY][MAX_PLY];

int follow_pv, score_pv;

/**************

Transposition table

***************/
//aantal hash table entries
int hash_entries = 0;

//no hash entry found constant
#define no_hash_entry 100000

//transposition table hash flags
#define hash_flag_exact   0
#define hash_flag_alpha   1
#define hash_flag_beta    2


//transposition table structure
typedef struct  {
    U64 hash_key;
    int depth;
    int flag; //flag type of node (alpha cutoff/beta cutoff/PV)
    int score; //(alpha/beta/PC)
    int best_move;
}   tt; //transposition table

// define TT instance
tt *hash_table = NULL;

void clear_hash_table()
{
    tt *hash_entry;

     //loop over hash_table elements
    for (hash_entry = hash_table; hash_entry < hash_table + hash_entries; hash_entry++)
     {
        //reset TT inner fields
        hash_entry->hash_key = 0;
        hash_entry->depth = 0;
        hash_entry->flag = 0;
        hash_entry->score = 0;
     }
}

// dynamically allocate memory for hash table
void init_hash_table(int mb)
{
    // init hash size
    int hash_size = 0x100000 * mb;

    // init number of hash entries
    hash_entries =  hash_size / sizeof(tt);

    // free hash table if not empty
    if (hash_table != NULL)
    {
        printf("    Clearing hash memory...\n");

        // free hash table dynamic memory
        free(hash_table);
    }

    // allocate memory
    hash_table = (tt *) malloc(hash_entries * sizeof(tt));

    // if allocation has failed
    if (hash_table == NULL)
    {
        printf("    Couldn't allocate memory for hash table, tryinr %dMB...", mb / 2);

        // try to allocate with half size
        init_hash_table(mb / 2);
    }

    // if allocation succeeded
    else
    {
        // clear hash table
        clear_hash_table();

        printf("    Hash table is initialied with %d entries\n", hash_entries);
    }
}

//Lees de hash entry data
static inline int read_hash_entry(int alpha, int beta, int* best_move, int depth)
{
    //Create a TT instance pointer naar de entry voor het opslaan
    tt *hash_entry = &hash_table[hash_key % hash_entries];

    //Zeker weten dat de precieze positie wordt gepakt
    if (hash_entry->hash_key == hash_key)
    {
        //Zelfde depth
        if (hash_entry->depth >= depth)
        {

            // get score form hash
            int score = hash_entry->score;

            if (score < -mate_score) score += ply;
            if (score > mate_score) score -= ply;


            //Match pv node score
            if (hash_entry->flag == hash_flag_exact)
                //Return exact pv node score
                return score;

            //Match alpha, fail low node score
            if ((hash_entry->flag == hash_flag_alpha) && (score <= alpha))
                //Return exact pv node score
                return alpha;

            //Match beta, fail high node score
            if ((hash_entry->flag == hash_flag_beta) && (score >= beta))
                //Return exact pv node score
                return beta;
        }
        *best_move = hash_entry->best_move;
    }
    //Als de hash->entry niet bestaat
    return no_hash_entry;
}

//Schrijf de hash entry data
static inline void write_hash_entry(int score, int best_move, int depth, int hash_flag)
{
    //Create a TT instance pointer naar de entry voor het opslaan
    tt *hash_entry = &hash_table[hash_key % hash_entries];

    // store score independent from the actual path
    // from root node (position) to current node (position)
    if (score < -mate_score) score -= ply;
    if (score > mate_score) score += ply;

    //Schrijf de hash entry data
    hash_entry->hash_key = hash_key;
    hash_entry->score = score;
    hash_entry->flag = hash_flag;
    hash_entry->depth = depth;
    hash_entry->best_move = best_move;
}

// enable PV scoring
static inline void enable_pv_scoring(moves* move_list)
{
    // als we het gaan scoren, moeten we follow pv uitzetten
    follow_pv = 0;
    // over de moves in de move lijst loopen
    for (int count = 0; count < move_list->count; count++)
    {
        // hebben we de pv move
        if (pv_table[0][ply] == move_list->moves[count])
        {
            // enable move scoring
            score_pv = 1;
            // pv weer aanzetten
            follow_pv = 1;
        }
    }
}

//Geef elke zet een score kwa goed/slecht.
static inline int score_move(int move)
{
    // als pv move scoring aan staat
    if (score_pv)
    {
        // checken of het de pv move is
        if (pv_table[0][ply] == move)
        {
            // disable score PV flag
            score_pv = 0;
            // geef pv de hoogste score, zodat het als eerste move opkomt
            return 20000;
        }
    }

    //Capture moves.
    if (get_move_capture(move))
    {
        //Het stuk
        int piece = get_move_piece(move);

        //Target_piece = witte pion (startwaarde vanwege ennpassant, anders crashed die).
        int target_piece = P;
        //Start_piece en end_piece oproepen.
        int start_piece, end_piece;

        //Als wit, dan loop zwarte stukken, als zwart dan loop witte stukken.
        if (side == white) { start_piece = p; end_piece = k; }
        else { start_piece = P; end_piece = K; }

        //Loop over bitboards van tegenstander.
        for (int bb_piece = start_piece; bb_piece <= end_piece; bb_piece++)
        {
            //Zoek het stuk van de tegenstander dat op het gegeven vakje staat.
            if (get_bit(bitboards[bb_piece], get_move_target(move)))
            {
                //Target_piece = aangevallen stuk;
                target_piece = bb_piece;
                break;
            }
        }
        //  extract move features
	    int source_square = get_move_source(move);
	    int target_square = get_move_target(move);

	    // make the first capture, so that X-ray defender show up
	    pop_bit(bitboards[piece], source_square);

	    // captures of undefended pieces are good by definition
	    if (!is_square_attacked(target_square, side ^ 1)) {
		    // restore captured piece
		    set_bit(bitboards[piece], source_square);

		    // score undefended captures greater than other captures
		    return 15000;
	    }

	    // restore captured piece
	    set_bit(bitboards[piece], source_square);

        // score move by MVV LVA lookup [source piece][target piece]
        return mvv_lva[piece][target_piece] + 10000;
    }

    // Score quiet move.
    else
    {
        //score eerste killer move.
        if (killer_moves[0][ply] == move)
            return 9000;
        //score tweede killer move.
        else if (killer_moves[1][ply] == move)
            return 8000;
        else
            //score history moves
            return history_moves[get_move_piece(move)][get_move_target(move)];
    }
    return 0;
}

//Sort moves op basis van score (hoog naar laag).
static inline int sort_moves(moves* move_list, int best_move)
{
    //Move scores array. Deze array is even groot als het aantal moves in move_list.
    int move_scores[move_list->count];

    //Loop over alle moves in move_list.
    for (int count = 0; count < move_list->count; count++)
        if (best_move == move_list->moves[count])
            // score move
            move_scores[count] = 30000;

        else
            // score move
            move_scores[count] = score_move(move_list->moves[count]);

    //Loop over current move in move_list.
    for (int current = 0; current < move_list->count; current++)
    {
        //Loop over volgende move in move_list.
        for (int next = current + 1; next < move_list->count; next++)
        {
            //Als current move_score is kleiner dan volgende move_score. Dan switch de zetten.
            if (move_scores[current] < move_scores[next])
            {
                //Store current score.
                int temp_score = move_scores[current];
                //Move_score wordt move_score van volgende.
                move_scores[current] = move_scores[next];
                //Move score van volgende wordt temp_score wat de move score van current is.
                move_scores[next] = temp_score;

                //Precies hetzelfde als de score hierboven maar dan met de move ipv score.
                int temp_move = move_list->moves[current];
                move_list->moves[current] = move_list->moves[next];
                move_list->moves[next] = temp_move;
            }
        }
    }

}

//Print move scores.
void print_move_scores(moves* move_list)
{
    //Print "Move scores:".
    printf("     Move scores:\n\n");

    //Loop over moves in move_list.
    for (int count = 0; count < move_list->count; count++)
    {
        //Print zet en score zoals "move: e2e4 score: 0".
        printf("     move: ");
        print_move(move_list->moves[count]);
        printf(" score: %d\n", score_move(move_list->moves[count]));
    }
}

//Repetition draw detection
static inline int is_repetition()
{
    //Loop over repetition index bereik
    for (int index = 0; index < repetition_index; index++)
        //Als de hash key hetzelfde is als eerder dus repetitie
        if (repetition_table[index] == hash_key)
            //Repetitie dus true
            return 1;

    //Als geen repetition, dan 0
    return 0;
}

// quiescence search
static inline int quiescence(int alpha, int beta)
{
    if((nodes & 2047)== 0)
        communicate();
    // verhoog node count
    nodes++;

    // zorgt ervoor dat engine niet crash (ofwel niet overflowt)
    if (ply > MAX_PLY - 1)
        return evaluate();

    // evaluatie functie
    int eval = evaluate();

    if (eval >= beta)
    {
        return beta;
    }

    if (eval > alpha)
    {
        alpha = eval;
    }

    moves move_list[1];

    //generate moves
    generate_moves(move_list);

    sort_moves(move_list, 0);

    //loop over moves within a movelist
    for (int count = 0; count < move_list->count; count++)
    {
        //preserve board state
        copy_board();
        //verhoog ply
        ply++;

        //Verhoog index met 1 en sla de hash key op
        repetition_index++;
        repetition_table[repetition_index] = hash_key;

        //alleen legale moves
        if (make_move(move_list->moves[count], only_captures) == 0)
        {
            //Ply -1.
            ply--;

            //Verlaag index met 1
            repetition_index--;

            //Ga naar volgende zet.
            continue;
        }
        //score current move
        int score = -quiescence(-beta, -alpha);

        //verlaag ply
        ply--;

        //Verlaag index met 1
        repetition_index--;

        //take move back
        take_back();

        //return 0 als de tijd op is
        if (stopped == 1) return 0;



        //found a better move
        if (score > alpha)
            {
                //PV node (move)
                alpha = score;

                 //fail hard beta cutoff
            if (score >= beta)
            {
                //node (move) fails high
                return beta;
            }
        }
    }
    //node (move) fails low (of hetzelfde dan alpha of lager)
    return alpha;
}
const int full_depth_moves = 4;
const int reduction_limit = 3;


//Negamax alpha-beta search.
static inline int negamax(int alpha, int beta, int depth)
{
    // init pv length
    pv_length[ply] = ply;

    //Variabele to score current move (van de static evaluation)
    int score;

    //best move om op te slaan in transpostition table
    int best_move = 0;

    //define hash flag
    int hash_flag = hash_flag_alpha;

    //Als repetitie
    if (ply && is_repetition() || fifty >= 100)
        //Geef gelijkspel score
        return 0;

    //Hack om erachter te komen of de node pv is of niet
    int pv_node = beta - alpha > 1;

    //read hash entry als niet de pv
    if (ply &&(score = read_hash_entry(alpha, beta, &best_move, depth)) != no_hash_entry && pv_node == 0)
    //als de move al eens is gezocht en dus al een waarde heeft
        return score;

       // elke 2047 nodes.
    if ((nodes & 2047) == 0)
        //krijg gui input
        communicate();

    //Als de depth 0 is, dan return iets??
    if (depth == 0)
        return quiescence(alpha, beta);
    // zorgt ervoor dat engine niet crash (ofwel niet overflowt)
    if (ply > MAX_PLY - 1)
        return evaluate();

    //Vergroot nodes.
    nodes++;

    //Variabele in_check (koning).
    int in_check = is_square_attacked((side == white) ? get_ls1b_index(bitboards[K]) :
        get_ls1b_index(bitboards[k]), side ^ 1);

    if (in_check) depth++;

    //Legal moves variabele.
    int legal_moves = 0;

    // get static evaluation score
	int static_eval = evaluate();

	    // evaluation pruning / static null move pruning
	if (depth < 3 && !pv_node && !in_check &&  abs(beta - 1) > -infinity + 100)
	{
        // define evaluation margin
		int eval_margin = 120 * depth;

		// evaluation margin substracted from static evaluation score fails high
		if (static_eval - eval_margin >= beta)
		    // evaluation margin substracted from static evaluation score
			return static_eval - eval_margin;
	}

    //null move pruning
    if (depth >= 3 && in_check == 0 && ply)
    {
        //preserve board state
        copy_board();

        //increment ply
        ply++;

        //Verhoog index met 1 en sla de hash key op
        repetition_index++;
        repetition_table[repetition_index] = hash_key;

        //Update hash enpassant als mogelijk
        if (enpassant != no_sq) hash_key ^= enpassant_keys[enpassant];

        //reset enpassement capture square naar niks
        enpassant = no_sq;

        //switching side, so opponent has an extra move to make
        side ^= 1;

        //Hash de kant
        hash_key ^= side_key;

        //search moves with reduced search depth to find beta cutoffs (R is dus een reduction limit)
        score = -negamax(-beta, -beta + 1, depth - 1 - 2);

         //decrement ply
        ply--;

        //Verlaag index met 1
        repetition_index--;

        //restore board state
        take_back();

        if (stopped == 1) return 0;

        //fail hard beta cutoff
        if (score >= beta)
            return beta;
    }

    // razoring
    if (!pv_node && !in_check && depth <= 3)
    {
        // get static eval and add first bonus
        score = static_eval + 125;

        // define new score
        int new_score;

        // static evaluation indicates a fail-low node
        if (score < beta)
        {
            // on depth 1
            if (depth == 1)
            {
                // get quiscence score
                new_score = quiescence(alpha, beta);

                // return quiescence score if it's greater then static evaluation score
                return (new_score > score) ? new_score : score;
            }

            // add second bonus to static evaluation
            score += 175;

            // static evaluation indicates a fail-low node
            if (score < beta && depth <= 2)
            {
                // get quiscence score
                new_score = quiescence(alpha, beta);

                // quiescence score indicates fail-low node
                if (new_score < beta)
                    // return quiescence score if it's greater then static evaluation score
                    return (new_score > score) ? new_score : score;
            }
        }
	}

    //CreeÃ«r move list genaamd moves.
    moves move_list[1];
    //Genereer zetten.
    generate_moves(move_list);

    // als we pv gebruiken, dan moet de pv move gescored worden
    if (follow_pv)
        // dus zet pv scoring aan
        enable_pv_scoring(move_list);

    sort_moves(move_list, best_move);

    //number of moves searched in a move list
    int moves_searched = 0;

    //Loop over zetten in move_list.
    for (int count = 0; count < move_list->count; count++)
    {
        //Maak een kopie van het board.
        copy_board();
        //Half move++
        ply++;

        //Verhoog index met 1 en sla de hash key op
        repetition_index++;
        repetition_table[repetition_index] = hash_key;

        //Als zet niet legaal is, dan ply - 1.
        if (make_move(move_list->moves[count], all_moves) == 0)
        {
            //Ply -1 en ga verder.
            ply--;

            //Verlaag index met 1
            repetition_index--;

            continue;
        }
        //Legale zetten +1
        legal_moves++;

        // Full depth searched
        if (moves_searched == 0) // First move, use full-window search
        //Geef de zet een score.
            score = -negamax( -beta, -alpha, depth - 1);

        // LMR
        else
        {
            // condition to consider LMR
            if (
                moves_searched >= full_depth_moves &&
                depth >= reduction_limit &&
                in_check == 0 &&
                get_move_capture(move_list->moves[count]) == 0 &&
                get_move_promoted(move_list->moves[count]) == 0
                )
                // Search this move with reduced depth:
                score = -negamax(-alpha - 1, -alpha, depth - 2);

                // Hack to ensure that full-depth search is done.
            else score = alpha + 1;

            // PVS
            if (score > alpha)
            {
                //Wanneer je een score hebt gevonden tussen alpha en beta, de rest van de moves wordt dan vanuit gegaan dat ze slecht zijn. Dit is sneller dan als gedacht wordt dat er wel nog een goede move is.
                score = -negamax(-alpha - 1, -alpha, depth - 1);

                // Als er toch een betere move is, dan moet op de normale alpha beta manier gezocht worden.
                if ((score > alpha) && (score < beta))
                    score = -negamax(-beta, -alpha, depth - 1);
            }
        }



        //Ply -1.
        ply--;

        //Verlaag index met 1
        repetition_index--;

        //Zet terug nemen.
        take_back();

        //return 0 als de tijd op is
        if (stopped == 1) return 0;

        //increment moves searched
        moves_searched++;

        //Als de score groter is dan alpha (betere zet).
        if (score > alpha)
        {
            //switch hash flag from scoring score for alpha to PV
            hash_flag = hash_flag_exact;

            best_move = move_list->moves[count];
            // voor quiet moves
            if (get_move_capture(move_list->moves[count]) == 0)
                //store history moves
                history_moves[get_move_piece(move_list->moves[count])][get_move_target(move_list->moves[count])] += depth;

            //Stel alpha gelijk aan score.
            alpha = score;

            // schrijf een pv move uit de tabel
            pv_table[ply][ply] = move_list->moves[count];
            // loop over de ply
            for (int next_ply = ply + 1; next_ply < pv_length[ply + 1]; next_ply++)
                // De volgende moves die nog moeten komen uit de tabel moeten in de lijn van deze ply worden gezet
                pv_table[ply][next_ply] = pv_table[ply + 1][next_ply];

            // verander pv length
            pv_length[ply] = pv_length[ply + 1];
            //Als de score groter of gelijk is aan beta. (Node fails high).

            if (score >= beta)
            {
                // store hash entry with score equal to beta
                write_hash_entry(beta, best_move, depth, hash_flag_beta);
                // voor quiet moves
                if (get_move_capture(move_list->moves[count]) == 0)
                {
                    //store killer moves
                    killer_moves[1][ply] = killer_moves[0][ply];
                    killer_moves[0][ply] = move_list->moves[count];
                }
                //Return beta.
                return beta;
            }
        }
    }
    //Als er geen legale zetten zijn.
    if (legal_moves == 0)
    {
        //En als de koning in check is.
        if (in_check)
            //Dan return mate. +ply want mate in 1 gaat voor mate in 10.
            return -mate_value + ply;
        else
            //Anders stalemate.
            return 0;
    }
    // store hash entry with score equal to beta
    write_hash_entry(alpha, &best_move, depth, hash_flag);

    //Return alpha. (Node fails low).
    return alpha;
}

//Search positie voor beste zet.
void search_position(int depth)
{
    //Sla de starttijd op
    int start = get_time_ms();
    int score = 0;
    //reset nodes teller voor nieuwe evaluation
    nodes = 0;
    //reset time is op flag
    stopped = 0;
    //reset pv flags
    follow_pv = 0;
    score_pv = 0;
    // clear "cache" van gebruikte tabellen van de killer moves/history moves/ pv table/ pv length
    memset(killer_moves, 0, sizeof(killer_moves));
    memset(history_moves, 0, sizeof(history_moves));
    memset(pv_table, 0, sizeof(pv_table));
    memset(pv_length, 0, sizeof(pv_length));



    //Define alpha beta values
    int alpha = -infinity;
    int beta = infinity;

    // iterative deepening (evaluation maar dan per depth)
    for (int current = 1; current <= depth; current++)
    {
        //als de tijd op is
        if (stopped == 1)
            //stop calculating zetten en geef de beste zet
            break;

        // we volgen pv, dus we zetten pv aan
        follow_pv = 1;
        //Zoek de beste zet in de gegeven positie.
        int score = negamax(alpha, beta, current);

        if ((score <= alpha) || (score >= beta)) {
            alpha = -infinity;    // We fell outside the window, so try again with a
            beta = infinity;      //  full-width window (and the same depth).
            continue;

        }
        // Set up the window for the next iteration.
        alpha = score - 50;
        beta = score + 50;

        if (pv_length[0])
        {

            //Print belangrijke info
            if (score > -mate_value && score < -mate_score)
                printf("info score mate %d depth %d nodes %lld time %d pv ", -(score + mate_value) / 2 - 1, current, nodes, get_time_ms() - start);

            else if (score > mate_score && score < mate_value)
                printf("info score mate %d depth %d nodes %lld time %d pv ", (mate_value - score) / 2 + 1, current, nodes, get_time_ms() - start);

            else
                printf("info score cp %d depth %d nodes %lld time %d pv ", score, current, nodes, get_time_ms() - start);

            for (int count = 0; count < pv_length[0]; count++)
            {
                print_move(pv_table[0][count]);
                printf(" ");
            }
            printf("\n");
        }
    }
    //Print best move
    printf("bestmove ");

    if (pv_table[0][0])
        print_move(pv_table[0][0]);

    else
        //Niks
        printf("(none)");

    printf("\n");
}


/**************

UCI

***************/
//Geef de user/GUI move string input (bv e7e8q). (binnen de haakjes is anders in vid 44)
int parse_move(char *move_string)
    {
    //Generate move list.
    moves move_list[1];
    //Generate moves.
    generate_moves(move_list);

    //Eerste 2 letters/cijfers van move_string (source square).
    int source_square = (move_string[0] - 'a') + (8 - (move_string[1] - '0')) * 8;
    //Derde en vierde letters/cijfers van move_string (target square).
    int target_square = (move_string[2] - 'a') + (8 - (move_string[3] - '0')) * 8;

    //Loop moves in move list.
    for (int move_count = 0; move_count < move_list->count; move_count++)
    {
        //Init move.
        int move = move_list->moves[move_count];
        //Zeker weten dat de source_square en target_square mogelijk zijn.
        if (source_square == get_move_source(move) && target_square == get_move_target(move))
        {
            //Init promoted piece.
            int promoted_piece = get_move_promoted(move);
 // promoted piece is available
            if (promoted_piece)
            {
                // promoted to queen
                if ((promoted_piece == Q || promoted_piece == q) && move_string[4] == 'q')
                    // return legal move
                    return move;
                // promoted to rook
                else if ((promoted_piece == R || promoted_piece == r) && move_string[4] == 'r')
                    // return legal move
                    return move;
                // promoted to bishop
                else if ((promoted_piece == B || promoted_piece == b) && move_string[4] == 'b')
                    // return legal move
                    return move;
                // promoted to knight
                else if ((promoted_piece == N || promoted_piece == n) && move_string[4] == 'n')
                    // return legal move
                    return move;
                // continue the loop on possible wrong promotions (e.g. "e7e8f")
                continue;
            }
            // return legal move
            return move;
        }
    }
    // return illegal move
    return 0;

}

//Parce uci position commmand.
void parse_position(char* command)
{
    //Ga 9 tekens verder in de command. (bv "postion startpos" leest die vanaf startpos want dat is belangrijk en daarvoor niet).
    command += 9;
    //Current_char = command.
    char* current_char = command;

    //Als de letters na postition startpos zijn dus command "position startpos".
    if (strncmp(command, "startpos", 8) == 0)
        //Dan fen = start_position.
        parse_fen(start_position);
    //Anders.
    else
    {

        //Current_char = fen command is in string.
        current_char = strstr(command, "fen");

        //Als er geen fen is in current_char.
        if (current_char == NULL)
            //Fen = startposition
            parse_fen(start_position);
        //Anders (wel een fen).
        else
        {
            //Ga 4 verder (skip fen en de spatie).
            current_char += 4;
            //Parse_fen wat over is (de fen).
            parse_fen(current_char);
        }
    }
    //Parse moves na de fen.
    current_char = strstr(command, "moves");

    //Als er nog zetten zijn.
    if (current_char != NULL)
    {
        //Ga 6 verder, moves en een spatie.
        current_char += 6;
        //Loop over tekens in de overige string.
        while (*current_char)
        {
            //Een legale zet of 0 als illegaal.
            int move = parse_move(current_char);
            //Als er niet meer zetten zijn.
            if (move == 0)
                //Stop de loop.
                break;

            //Verhoog repetition index
            repetition_index++;
            //Schrijf hash key in repetition table
            repetition_table[repetition_index] = hash_key;

            //Doe de zetten.
            make_move(move, all_moves);
            //Zolang er geen spatie is, naar volgende teken gaan.
            while (*current_char && *current_char != ' ') current_char++;
            //Ga naar volgende zet.
            current_char++;
        }
    }

    print_board();
}

// reset time control variables
void reset_time_control()
{
    // reset timing
    quit = 0;
    movestogo = 30;
    movetime = -1;
    time = -1;
    inc = 0;
    starttime = 0;
    stoptime = 0;
    timeset = 0;
    stopped = 0;
}

//UCI go command.
void parse_go(char* command)
{
    //reset tijd dingen
    reset_time_control();

    // init parameters
    int depth = -1;

    // init argument
    char* argument = NULL;

    // infinite search
    if ((argument = strstr(command, "infinite"))) {}

    // match UCI "binc" command
    if ((argument = strstr(command, "binc")) && side == black)
        // parse black time increment
        inc = atoi(argument + 5);

    // match UCI "winc" command
    if ((argument = strstr(command, "winc")) && side == white)
        // parse white time increment
        inc = atoi(argument + 5);

    // match UCI "wtime" command
    if ((argument = strstr(command, "wtime")) && side == white)
        // parse white time limit
        time = atoi(argument + 6);

    // match UCI "btime" command
    if ((argument = strstr(command, "btime")) && side == black)
        // parse black time limit
        time = atoi(argument + 6);

    // match UCI "movestogo" command
    if ((argument = strstr(command, "movestogo")))
        // parse number of moves to go
        movestogo = atoi(argument + 10);

    // match UCI "movetime" command
    if ((argument = strstr(command, "movetime")))
        // parse amount of time allowed to spend to make a move
        movetime = atoi(argument + 9);

    // match UCI "depth" command
    if ((argument = strstr(command, "depth")))
        // parse search depth
        depth = atoi(argument + 6);

    // if move time is not available
    if (movetime != -1)
    {
        // set time equal to move time
        time = movetime;

        // set moves to go to 1
        movestogo = 1;
    }

    // init start time
    starttime = get_time_ms();

    // init search depth
    depth = depth;

    // if time control is available
    if (time != -1)
    {
        // flag we're playing with time control
        timeset = 1;

        // set up timing
        time /= movestogo;

        // lag compensation
        time -= 50;

        // if time is up
        if (time < 0)
        {
            // restore negative time to 0
            time = 0;

            // inc lag compensation on 0+inc time controls
            inc -= 50;

            // timing for 0 seconds left and no inc
            if (inc < 0) inc = 1;
        }

        // init stoptime
        stoptime = starttime + time + inc;
    }

    // if depth is not available
    if (depth == -1)
        // set depth to 64 plies (takes ages to complete...)
        depth = 64;

    // print debug info
    printf("time: %d  inc: %d  start: %u  stop: %u  depth: %d  timeset:%d\n",
            time, inc, starttime, stoptime, depth, timeset);

    //idk???
    search_position(depth);
}

//Belangrijkste UCI loop
void uci_loop()
{
    // max hash MB
    int max_hash = 128;

    // default MB value
    int mb = 64;

    //Reset stdin en stdout buffers.
    setbuf(stdin, NULL);
    setbuf(stdout, NULL);

    //Groot nummer want moet altijd genoeg tekens zijn in de input, kan best veel zijn.
    char input[10000];

    //Print engine info
    printf("id name AlphaEngine\n");
    printf("id author Mart en Krijn:)\n");
    printf("uciok\n");

    //Main loop (1 staat voor true)
    while (1)
    {
        //Reset user /gui input.
        memset(input, 0, sizeof(input));
        //Zorgt ervoor dat de output bij de gui aankomt.
        fflush(stdout);

        //Get user / GUI input.
        if (!fgets(input, 2000, stdin))
            continue;

        //Anders check dat het niet begint met een nieuwe regel.
        if (input[0] == '\n')
            continue;

        //Anders als isready, dan print readyok.
        if (strncmp(input, "isready", 7) == 0)
        {
            //Print ready ok met een nieuwe regel.
            printf("readyok\n");
            continue;
        }

        //Anders als position, dan parse position.
        else if (strncmp(input, "position", 8) == 0)
        {
            parse_position(input);
            //Clear hash table
            clear_hash_table();
        }

        //Anders als ucinewgame, dan parse start_position.
        else if (strncmp(input, "ucinewgame", 10) == 0)
        {
            parse_position("position startpos");
            //Clear hash table
            clear_hash_table();
        }

        //Anders als go, dan parse go.
        else if (strncmp(input, "go", 2) == 0)
            parse_go(input);

        //Anders als quit, dan break (stop).
        else if (strncmp(input, "quit", 4) == 0)
            break;

        //Anders als uci, dan info printen.
        else if (strncmp(input, "uci", 3) == 0)
        {
            printf("id name AlphaEngine\n");
            printf("id author Mart\n");
            printf("uciok\n");
        }
        else if (!strncmp(input, "setoption name Hash value ", 26))
        {
            // init MB
            sscanf(input,"%*s %*s %*s %*s %d", &mb);

            // adjust MB if going beyond the aloowed bounds
            if(mb < 4) mb = 4;
            if(mb > max_hash) mb = max_hash;

            // set hash table size in MB
            printf("    Set hash table size to %dMB\n", mb);
            init_hash_table(mb);
        }
    }
}



/**********************************\
 ==================================

              Init all

 ==================================
\**********************************/

// init all variables soort van opvragen zodat de computer ze herinnert
void init_all()
{
    // init leaper pieces attacks
    init_leapers_attacks();

    // init slider pieces attacks
    init_sliders_attacks(bishop);
    init_sliders_attacks(rook);

    // init magic numbers
    //init_magic_numbers();

    // init random keys for hashing purposes
    init_random_keys();

    // init evaluation masks
    init_evaluation_masks();

    // init hash table with default 64 MB
    init_hash_table(64);
}


/**********************************\
 ==================================

             Main driver

 ==================================
\**********************************/
//Main loop
int main()
{
    //Init all
    init_all();

    //Debug mode variable, 0 is uit en 1 is aan
    int debug = 0;

    //Als debuggen aan staat, dan...
    if (debug)
    {
        //Parse start pos
        parse_fen(draw_position);
        //Print het spelbord
        print_board();
        //Zoek de positie 10 zetten diep
        search_position(1);

        //Maak de beste zet
        make_move(pv_table[0][0], all_moves);
        search_position(1);
    }

    //Als debug uit staat, dan..
    else
        //UCI loop voor het echte spelen
        uci_loop();
        free(hash_table);

    return 0;
}
